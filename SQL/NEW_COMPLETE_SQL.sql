# DDL (CREATE,ALTER,DROP,TRUNCATE)

# CREATE DATABASE , DROP DATABASE

CREATE DATABASE FLIPKART_DB;  # COMMAND TO CREATE DTABASE
CREATE DATABASE MEESHO;
CREATE DATABASE MYNTRA;
create database jabong;       ## WE CAN WRITE ALL CODE IN LOSWER-CASE ALSO.

# CREATE DATABASE              # COMMAND TO CREATE DTABASE
CREATE DATABASE EBAY_DB;
#      ^
#      |
#      V
# DROP DATABASE                # COMMAND IS USED TO DROP A DATABASE
DROP DATABASE EBAY_DB         

# DQL (SELECT)
SELECT DATABASE();            # COMMAND IS USED TO CHECK WHICH DATABASE IS ACTIVE

USE FLIPKART_DB;              # COMMAND IS USED, 'TO USE' THE DATABASE. OR WE CAN SAY THAT TO ACTIVATE THE DATABASE.
SHOW TABLES;                  # COMMAND IS USED TO DISPLAY ALL 'TABLES' IN A 'ACTIVE DATABASE'.


 # CREATE TABLE , DROP TABLE
 
 # CREATE TABLE 
CREATE TABLE CUSTOMER_TB      # COMMAND IS USED TO CREATE TABLE INSIDE THE DATABASE 
(
CUST_NAME VARCHAR(20),        #
CUST_ADDRESS VARCHAR(30),     # SCHEMA OF TABLE
CUST_PHONENUMBER BIGINT       #
);
SELECT * FROM CUSTOMER_TB;    #  COMMAND IS USED TO SHOW THE CONTENT INSIDE THE TABLE.

#

CREATE TABLE PRODUCT_TB
(
P_ID INT,
P_NAME VARCHAR(50),
P_COMPANY VARCHAR(50),
PRICE INT
);
 SELECT * FROM PRODUCT_TB;
 
 # DROP TABLE
 DROP TABLE PRODUCT_TB;        # COMMAND IS USED TO DROP THE TABLE. COMPLETE STRUCTURE OF TABLE GET'S DELETED ALONG WITH DATA.
 
# DML (INSERT,UPDATE,DELETE,SELECT)
 
 # INSERT
# INSERTING DATA:--->
INSERT INTO CUSTOMER_TB VALUES ("ANIKET", "JPNAGAR", 8180868800);
INSERT INTO CUSTOMER_TB VALUES ("SANKET", "JPNAGAR", 80868800);
INSERT INTO CUSTOMER_TB VALUES ("SHREENATH", "KHAMLA",8990868800);
INSERT INTO CUSTOMER_TB VALUES ("PRASAD", "NEWSNEHANAGAR", 9187868800);


INSERT INTO CUSTOMER_TB VALUES ("WAGHA", "JPNAGAR"," ");
# IT WILL GIVE US ERROR
INSERT INTO CUSTOMER_TB VALUES ("WAGHA", "JPNAGAR",NULL);
# NOW HERE IT WILL NOT GIVE US ERROR.


INSERT INTO CUSTOMER_TB (CUST_NAME,CUST_ADDRESS,CUST_PHONENUMBER)VALUES("KARTHIK", "BANGALORE", 9187878800);
# WE CAN INSERT DATA INTO TABLE WITH 2 WAYS, LINE 57,62,73,77.


INSERT INTO CUSTOMER_TB VALUES ("TOM", "USA");
# [NOW HERE IF TRY TO INSERT THE DATA, IT WILL GIVE US "ERROR", IN SCHEMA THERE ARE 3 COLUMNS BUT WE ARE INSERTING 2 VALUES ONLY, SO THATS WHY DATA
# DOESN'T KNOW THAT IN WHICH COLUMN WE HAVE TO SEAT. SO TO HANDLE THIS ERROR WRITE QUERY IN FOLLOWING MANNER.]
INSERT INTO CUSTOMER_TB (CUST_NAME,CUST_ADDRESS)VALUES("TOM", "USA");
# NOW IT WILL NOT GIVE US AN ERROR.


INSERT INTO CUSTOMER_TB (CUST_ADDRESS,CUST_NAME,CUST_PHONENUMBER)VALUES( "NASHIK","SWARA", 9187879900);
# WE CAN JUMBLE THE COLUMN NAMES AND THERE VALUES ALSO.

# WE CAN INSERT DATA IN FOLLOWING WAY ALSO..
INSERT INTO CUSTOMER_TB (CUST_ADDRESS,CUST_NAME,CUST_PHONENUMBER) VALUES( "AMRAVATI","SHANTYA", 9187779900), VALUES( "KARANJA","VAIBHAV", 9187874900);

# WE INSERTING FOLLOWING DATA ONLY TO LEARN HOW DELETE COMMAND WILL WORK IN DELETE SECTION, LINE NO:-93
INSERT INTO CUSTOMER_TB VALUES ("ANDYA", "JPNAGAR", 9187868890);
SELECT * FROM CUSTOMER_TB; 

#INSERT INTO CUSTOMER_TB VALUES ("ANDYA", "JPNAGAR", 9187868890,"M",67,null);
#SELECT * FROM CUSTOMER_TB; 

# UPDATE COMMAND
# NOW IF WE WANT TO ADD THE INFO INTO THE EXSISTING COLUMN THEN ALWAYS USE UPDATE COMMAND IN IT.
UPDATE CUSTOMER_TB SET CUST_PHONENUMBER = 8187878700 WHERE CUST_NAME="SWARA"; # HERE WE UPDATE ONLY ONE ROW
SELECT * FROM CUSTOMER_TB;

UPDATE CUSTOMER_TB SET EMAIL_ID="x.y.xyz@.com";   # HERE WE UPDATED ENTIRE COLUMN. # HERE, WE MISSED TO WRITE 'WHERE' CONDITION.
SELECT * FROM CUSTOMER_TB;


# DELETE COMMAND     [ DATA DELETED BUT SCHEMA IS THERE, WE CAN DELETE PERTICULR ROW ALSO.]
#                    [ AFTER USING THIS COMMAND WE ARE NOT LOOSING OUR DATA COMPLETELY,WE CAN ROLLBACK IT.]

DELETE FROM CUSTOMER_TB WHERE CUST_NAME="ANDYA";
#             OR [ FOLLOWING QUERRY TELLS US THAT WE CAN USE MULTIPLE CONDITIONS WHILE USING DELETE COMMAND ].

# DELETE FROM CUSTOMER_TB WHERE CUST_NAME="ANDYA" AND CUST_ADDRESS="JPNAGAR";
SELECT * FROM CUSTOMER_TB;

# ALTER VS UPDATE

# ALTER (ALTER COMMAND IS USED FOR) :->
# 1. ADD COLUMN IN TABLE.
# 2. CHANGE DATA TYPYE OF COLUMN.
# 3. CHANGE COLUMN NAME.
# 4. CHANGING COLUMN POSTION.
# 5. REMAINING TABLES 

# DDL OPERATION ON COLUMN LEVEL USE [ALTER]

# 1. CREATE COLUMN i.e. [ADD COLUMN] IN TABLE. FOR THIS WE REQUIRE 'ALTER' ----|
#                                                                              |
#                                                                              |
#  ALTER COLUMN  <------------------------<---------------------------<--------
# EX.1
ALTER TABLE CUSTOMER_TB ADD COLUMN CUST_GENDER CHAR(1); 
ALTER TABLE CUSTOMER_TB ADD COLUMN CUST_AGE BIGINT; 

ALTER TABLE CUSTOMER_TB ADD COLUMN EMAIL_ID VARCHAR(20); 
#                             OR
# ALTER TABLE CUSTOMER_TB ADD COLUMN EMAIL_ID VARCHAR(20) NOT NULL AFTER CUST_PHONENUMBER ;

# 2. DROP COLUMN i.e. [REMOVE COLUMN] IN TABLE. FOR THIS WE REQUIRE 'ALTER' -----------|
#                                                                                      |
#                                                                                      |
#  ALTER COLUMN  <------------------------<---------------------------<----------------

# EX. 1
# DROP CUSTOMER_TB   ---------> [COMPLETE STRUCTURE OF TABLE GET'S DELETED ALONG WITH DATA, BUT HERE WE WANT TO DROP ONLY COLUMN THEN]...

# WE CAN DROP COLUMNS ALSO BY SIMPLIY WRITING FOLLOWING QUERY
#                           |
#                           |
#                           V

# ( ALTER TABLE CUSTOMER_TB DROP COLUMN CUST_GENDER CHAR(1); )

#                      OR

#( ALTER TABLE CUSTOMER_TB DROP COLUMN EMAIL_ID; )
#                       OR
# ( ALTER TABLE CUSTOMER_TB DROP COLUMN EMAIL_ID IF EXISTS; ).  # EVEN IF "EMAIL_ID" COLUMN IS NOT IN TABLE. THIS WILL NOT GIVE ERROR,IT WILL GIVE US 
#                                                               WARNING.

# WE CAN GO WITH THE FOLLOWING WAY ALSO...
# ALTER TABLE CUSTOMER_TB
# DROP COLUMN EMAIL_ID, DROP COLUMN CUST_GENDER;

# RENAME COLUMN i.e. [CHANGING COLUMN NAME] IN TABLE. FOR THIS WE REQUIRE 'ALTER' 
 # IF WE WANT TO RENAME THE COLUMN NAME THEN 
ALTER TABLE CUSTOMER_TB RENAME COLUMN CUST_AGE TO AGE;
SELECT * FROM CUSTOMER_TB;

# CHANGE DATA TYPYE OF COLUMN IN TABLE.FOR THIS WE REQUIRE 'ALTER'
# ALTER TABLE CUSTOMER_TB MODIFY COLUMN CUST_NAME VARCHAR(255)

# EX. 2
# RENAME TABLE NAME i.e. [CHANGING TABLE NAME] FROM TABLE. FOR THIS WE REQUIRE 'ALTER'
# IF WE WANT TO RENAME THE TABLE NAME THEN 
  ALTER TABLE CUSTOMER_TB RENAME CUSTOMER_TB121;
  
  
# TRUNCATE  [AFTER USING THIS COMMAND WE LOST OUR DATA COMPLETELY,WE CAN'T ROLL BACK THE DATA]
CREATE TABLE DEPARTMENT
(
D_NAME VARCHAR(50),
D_CODE VARCHAR(50)
);
SELECT * FROM DEPARTMENT;

TRUNCATE TABLE DEPARTMENT;


# IF WE ARE WORKING INSIDE THE "JABONAG DATA BASE" AND ALL OF A SUDDEN IF WE WANT SOME DATA FROM 
# OTHER DATA BASE i.e. FLIPKART_DB THEN WE CAN USE THIS QUERY ALSO.  (SELECT * FROM DATABASE NAME.TABLE NAME)
  SELECT * FROM FLIPKART_DB.CUSTOMER_TB;
 

# UPDATE
# NOW IF WE WANT TO ADD THE INFO IN THIS NEW COLUMNS THEN ALWAYS USE UPDATE COMMAND IN IT
UPDATE CUSTOMER_TB SET AGE=25,CUST_GENDER="M" WHERE CUST_NAME="ANIKET";
UPDATE CUSTOMER_TB SET AGE=26,CUST_GENDER="M" WHERE CUST_NAME="SHREENATH";
SELECT * FROM CUSTOMER_TB;

UPDATE CUSTOMER_TB SET AGE=26 WHERE AGE=25;
SELECT * FROM CUSTOMER_TB;

UPDATE CUSTOMER_TB SET AGE=27, EMAIL_ID= 'PRASAD@GMAIL.COM' WHERE CUST_NAME='PRASAD';
SELECT * FROM CUSTOMER_TB;

UPDATE CUSTOMER_TB SET CUST_GENDER = 'M' WHERE CUST_NAME IN ('ANAND', 'DINESH', 'SATISH'); # UPDATE MULTIPLE ROW AT A TIME.

SELECT * FROM PHONE_NUMBER;  # NOT PRESENT THNE..
CREATE TABLE PHONE_NUMBER
(
NAME VARCHAR(50),
PHONE_NUMBAER BIGINT
);
SELECT * FROM PHONE_NUMBER;

# DCL (DATA CONTROL LANGUAGE)  [WE ARE NOT USE THIS COMMAND IT IS BEING USED BY DATABASE MANAGER.]

# 1.GRANT       [ # A GUY WHO GET THE JOB IN COMPANY, IT MANAGER IS GIVING ACCES TO THE CANDIDATE WITH THE HELP OF THIS COMMAND.]
GRANT SELECT ON FLIPKART_DB.PHONE_NUMBER TO VINAY;
GRANT SELECT ON FLIPKART_DB.PHONE_NUMBER TO HARSH;
GRANT SELECT ON FLIPKART_DB.PHONE_NUMBER TO ANIKET;
# AFTER RUNNING THIS IF WE GET ERROR IT MEANS THAT COMPANY HAS NOT GIVEN ACCES TO ALL NAMES WHICH ARE PRESENT IN ABOVE QUERY LIKE VINAY,HARSH,ANIKET.
 
GRANT INSERT ON FLIPKART_DB.PHONE_NUMBER TO HARSH;
GRANT UPDATE ON FLIPKART_DB.PHONE_NUMBER TO HARSH;
GRANT DELETE ON FLIPKART_DB.PHONE_NUMBER TO HARSH;
# WITH THE HELP OF GRANT COMMAND WE CAN GIVE ACCES TO CANDIDATE FOR INSERT , UPDATE AND DELETE OPERATIONN IN SQL.
 
 
SELECT USER(); # [AFTER EXECUTING THIS WE WILL GET THE USER NAME , HERE IT IS "root@localhost" THOSE WHO HAVE GOT THE ACCESS FROM COMPANY BUT IN REAL
               # TIME IT WILL SHOW OUR NAME BECAUSE COMPANY GAVE ACCESS TO US, IT WILL SHOW "aniketj" LIKE THAT.]
               
    
# 2.REVOKE         [ # NOW IF ANY CANDIDATE FROM COMPANY IS WANT TO LEAVE THE ORGANISATION THEN TAHT TIME DBMS MANAGER USE THIS COMMAND 
				    # IT IS REMOVING ACCESS OF SQL COMMANDS FROM CANDIDATE.]
REVOKE SELECT ON FLIPKART_DB.PHONE_NUMBAER FROM VINAY;


# TCL

# 1. COMMIT
# 2. ROLLBACK [ IT SIMPLY MEANS UNDO i.e. CONTRL+Z ]
# 3. SAVEPOINT

# 1ST WE WILL CREATE ONE TABLE

CREATE TABLE TCL_DB
(
ID INT,
NAME VARCHAR(20),
AGE INT
);
SELECT * FROM TCL_DB
 
 SET AUTOCOMMIT=0;  # IT MEANS UNLESS AND UNTILL I CONFIRNM YOU, DON'T GO AND SAVE IT TO THE MAIN SERVER.
 
# NOW WE WILL INSERT THE DATA INTO THE TABLE
INSERT INTO TCL_DB VALUES(1,'RAJA',25);
INSERT INTO TCL_DB VALUES(2,'ANIL',26);
INSERT INTO TCL_DB VALUES(3,'RAMU',24);
INSERT INTO TCL_DB VALUES(4,'ANAND',22);
INSERT INTO TCL_DB VALUES(5,'HARI',20);

SELECT * FROM TCL_DB;

# EX1.
# NOW WRITE THE FOLLOWING STSTEMENT IN "QUERY" IN BEGINING
START TRANSACTION; # START OF CODE [START TRANSACTION MEANS WHEN WE EXECUTE ROLLBACK AT ANY POINT OF TIME IT WILL THROW BACK TO THE 1ST STEP i.e.
                   # START TRANSACTION.]

DELETE FROM TCL_DB WHERE NAME="RAJA" # IF BY MISTAKE I RUN DELETE STATEMENT 1ST WITH THE HELP OF 'WHERE' AND THEN AFTER WITHOUT 'WHERE' WHICH IS 
                                     # DONE IN NEXT LINE. IF BY MISTAKE I RUN DELETE STATEMENT WITHOUT WHERE CONDITION THEN WHAT IT WILL HAPEN DELETE 
                                     # ENTIRE DATA FROM TABLE.
DELETE FROM TCL_DB;                    
SELECT * FROM TCL_DB;

ROLLBACK;                            # [ TO RETRIVE THE THE DATA AGAIN WE USE THIS COMMAND.WE EXECUTE ROLLBACK AT ANY POINT OF TIME IT WILL THROW BACK 
                                     # TO THE 1ST STEP i.e. START TRANSACTION. ]
SELECT * FROM TCL_DB;

# EX2.
START TRANSACTION;

UPDATE TCL_DB SET AGE=99 WHERE NAME="RAJA";    # HERE WE UPDATE DATA INCORRECTLY.
UPDATE TCL_DB SET AGE=99 WHERE NAME="ANIL";
SELECT * FROM TCL_DB;

ROLLBACK;                                      # WITH HELP OF 'ROLLBACK' WE CAN GO BACK TO THE ORIGNAL DATA.
SELECT * FROM TCL_DB; 

     # EX2.
START TRANSACTION;
SELECT * FROM TCL_DB;

UPDATE TCL_DB SET AGE=100 WHERE ID=1;
UPDATE TCL_DB SET AGE=100 WHERE ID=2;
SELECT * FROM TCL_DB;

COMMIT;              # HERE WE WROTE 'COMMIT' COMMAND, IT MEANS WHATEVER WE HAVE DONE PREVIOUSLY IT IS BEING SAVED IN DATABASE PERMANANTLY.WE 
                     # CAN'T RETRIVE IT BACK OR WE CAN'T DO CHANGES INTO IT. WE CAN DO IT BUT IT REQUIRE SOME PERMITIONS FROM DATABASE ADMINISTRATOR.

UPDATE TCL_DB SET AGE=100 WHERE ID=3;
UPDATE TCL_DB SET AGE=100 WHERE ID=4;
SELECT * FROM TCL_DB;
ROLLBACK;

SELECT * FROM TCL_DB;
                    

# 3. SAVEPOINT.     [SAVE THE 'CODE' OR WE CAN SAY SAVE THE 'TRANSACTIONS' OR WE CAN SAY THE 'WORK' AT EVERY SOME POINT OF TIME WHILE WRITING QUERY 
                     # i.e. WHILE WORKING. IT MEANS WE CAN SAY THAT IT IS PERFORMING SIMILAR OPERATION LIKE WORKING OF AUTOSAVE.]

# EX1.
START TRANSACTION;

SAVEPOINT A;
INSERT INTO TCL_DB VALUES(6,'NEW PERSON',25);
SELECT * FROM TCL_DB;

SAVEPOINT B;
UPDATE TCL_DB SET AGE=99 WHERE NAME="RAMU";
SELECT * FROM TCL_DB;

SAVEPOINT C;
DELETE FROM TCL_DB WHERE ID=1;
DELETE FROM TCL_DB WHERE ID=2;
DELETE FROM TCL_DB WHERE ID=3;
SELECT * FROM TCL_DB;

ROLLBACK TO C;
# ROLLBACK TO A/B/C     [ THESE ARE THE SAVE POINTS ]
SELECT * FROM TCL_DB;

# Ex2.
START TRANSACTION;

SAVEPOINT X;
SELECT * FROM TCL_DB;
ALTER TABLE TCL_DB ADD COLUMN COMPANY VARCHAR(20);
SELECT * FROM TCL_DB;

SAVEPOINT Y;
UPDATE TCL_DB SET COMPANY = "TCS";
SELECT * FROM TCL_DB;

ROLLBACK TO Y;
SELECT * FROM TCL_DB;
#       OR
# ROLLBACK TO X;
# SELECT * FROM TCL_DB; 

# ROLLBACK TO X
# ROLLBACK TO X  IF WE EXECUTE THIS THEN WE ARE EXPECTING THAT COLUMN 'COMPANY' SHOULD BE REMOVED BUT IN ACTUAL CASE IT IS NOT HAPPENING
# AS WE KNOW THAT WE USED 'ALTER' COMMAND WHICH IS DDL COMMAND SO THESE COMMAND CAN'T BE ROLLBACK. DML COMMANDS CAN BE ROLLBACK. 
# WE CAN RETRIVE DATA ONLY,NOT STRUCTURE.

# ROLLBACK TO Y
# ROLLBACK TO Y IF WE EXECUTE THIS THEN WE ARE EXPECTING THAT NAME "TCS" SHOULD BE REMOVED FROM 'COMPANY' COLUMN. AND YES IT IS HAPPENING.

SELECT * FROM TCL_DB;
 
## CONSTRAINTS. [ UNIQUE, AUTO INCRIMENT,PRIMARY KEY, NOT NULL, CHECK, FOREIGEN KEY]

# EX1

CREATE TABLE CUSTOMER_INFO
(
ID INT,

FIRST_NAME VARCHAR(20),
LAST_NAME VARCHAR(20),

AGE TINYINT,

ADDRESS VARCHAR(200),
LOCATION VARCHAR(10),

PHONE_NUMBAER BIGINT
);

# EX.2

CREATE TABLE CUSTOMER_INFO_1
(
ID INT PRIMARY KEY,

FIRST_NAME VARCHAR(20) NOT NULL,
LAST_NAME VARCHAR(20),
CHECK(FIRST_NAME<>LAST_NAME),   # <>     <----NOT EQUALTO

AGE TINYINT,
CHECK (AGE>18),

ADDRESS VARCHAR(100) UNIQUE,
LOCATION VARCHAR(10) DEFAULT 'INADIA',

PHONE_NUMBER BIGINT,
CHECK(LENGTH(PHONE_NUMBER)=10),
UNIQUE(PHONE_NUMBER)
);

#EX.3

CREATE TABLE CUSTOMER_INFO_2
(
ID INT,
CONSTRAINT PK_ID PRIMARY KEY(ID),
# CONSTRAINT UNIQ_PK_ID UNIQUE(ID),
# CONSTRAINT AUTO_UNIQ_PK_ID AUTO INCRIMENT(ID),

FIRST_NAME VARCHAR(20) NOT NULL,
LAST_NAME VARCHAR(20),
CONSTRAINT FN_LN_CHECK CHECK(FIRST_NAME<>LAST_NAME),

AGE TINYINT,
CONSTRAINT AGE_LIM1 CHECK (AGE>18),
# CONSTRAINT AGE_LIM2 CHECK (AGE>18 AND AGE<6 ),

ADDRESS VARCHAR(100) UNIQUE,
LOCATION VARCHAR(10) DEFAULT 'INADIA',

PHONE_NUMBER BIGINT,
CONSTRAINT PHONE_CHECK CHECK(LENGTH(PHONE_NUMBER)=10),
CONSTRAINT UNIQUE_PHONE_UK UNIQUE(PHONE_NUMBER)
);
# SEE THE EXAMPLE 2 & 3 ABOVE. SAME QUERY BUT WAY OF WRITING IS DIFFERINT. WE CAN GO WITH ANY ONE BUT MOST SUITABLE IS EX.3 

INSERT INTO CUSTOMER_INFO_2 VALUES (1,"ANIKET","JOSHI",25,"#97 JP NAGAR NAGPUR","MAHRASHTAR",8180868800); 


# INSERT INTO CUSTOMER_INFO_2 VALUES (1,"SARANSH","JOSHI",35,"#98 JP NAGAR NAGPUR","MAHRASHTAR",9766917303); THIS DATA CAN'T BE INSERTED BECAUSE ID IS 
# AS SAME ABOVE. TO INSERT THIS DATA INTO THE TABLE MAKE CORRECTION IN ID i.e. ID=2)
INSERT INTO CUSTOMER_INFO_2 VALUES (2,"SARANSH","JOSHI",35,"#98 JP NAGAR NAGPUR","MAHRASHTAR",9766917303);

# INSERT INTO CUSTOMER_INFO_2 VALUES (3,"SATISH","JOSHI",63,"#98 JP NAGAR NAGPUR","MAHRASHTAR",9423419307); THIS DATA CAN'T BE INSERTED BECAUSE ADD.
# IS AS SAME AS ABOVE.TO INSERT THIS DATA THE INTO TABLE MAKE CORRECTION IN ADDRESS i.e. ADDRESS=99)
INSERT INTO CUSTOMER_INFO_2 VALUES (3,"SATISH","JOSHI",63,"#99 JP NAGAR NAGPUR","MAHRASHTAR",9423419307);

# INSERT INTO CUSTOMER_INFO_2 VALUES (4,"VIDYA","JOSHI",59,"#100 JP NAGAR NAGPUR","MAHRASHTAR",942393531);THIS DATA CAN'T BE INSERTED BECAUSE 
# PHONE_NUMBER IS INCORRECT IT REQUIRE 10 DIGITS AND THERE ARE ONLY 9 DIGITS.TO INSERT THIS DATA THE INTO TABLE MAKE CORRECTION IN PHONE NO. i.e.
# PHONE_NUMBER=9423935317)
INSERT INTO CUSTOMER_INFO_2 VALUES (4,"VIDYA","JOSHI",59,"#100 JP NAGAR NAGPUR","MAHRASHTAR",9423935317)

# INSERT INTO CUSTOMER_INFO_2 VALUES (5,"KAPIL","JOSHI",25,"#101 JP NAGAR NAGPUR","MAHRASHTAR",9423935317) THIS DATA CAN'T BE INSERTED BECAUSE
# PHONE NO IS AS SAME AS ABOVE ROW.TO INSERT THIS DATA INTO THE TABLE MAKE CORRECTION IN PHONE NO. i.e. PHONE_NUMBER=9423935318
INSERT INTO CUSTOMER_INFO_2 VALUES (5,"KAPIL","JOSHI",25,"#101 JP NAGAR NAGPUR","MAHRASHTAR",9423935318)

# INSERT INTO CUSTOMER_INFO_2 VALUES (6,"SHRIRANG","SHRIRANG",29,"#102 JP NAGAR NAGPUR","MAHRASHTAR",9423935319)THIS DATA CAN'T BE INSERTED BECAUSE
# FIRST NAME AND LAST NAME BOTH ARE SAME.TO INSERT THIS DATA INTO THE TABLE MAKE CORRECTION IN LAST NAME i.e. LAST_NAME="JOSHI"
INSERT INTO CUSTOMER_INFO_2 VALUES (6,"SHRIRANG","JOSHI",29,"#102 JP NAGAR NAGPUR","MAHRASHTAR",9423935319)

# INSERT INTO CUSTOMER_INFO_2 VALUES (7,"AVRODH","JOSHI",1,"#103 JP NAGAR NAGPUR","MAHRASHTAR",9423935329) THIS DATA CAN'T BE INSERTED BECAUSE
# AGE IS OUT OF RANGE.TO INSERT THIS DATA INTO THE TABLE MAKE CORRECTION IN AGE i.e. AGE=ABOVE18 (19 or 20 or 21....). 

# HERE IN FOLLOWING INSERTING QUERY WE HAVE NOT MENTION THE LOCATION BUT STILL WE GOT 'INDIA' NAME IN TABLE. BECAUSE WE MENTION IT IN MAIN QUERY.
INSERT INTO CUSTOMER_INFO_2(ID,FIRST_NAME,LAST_NAME,AGE,ADDRESS,PHONE_NUMBER) VALUES (8,"AKIRA","JOSHI",20,"#104 JP NAGAR NAGPUR",9433935329)

# HERE IN FOLLOWING INSERTING QUERY WE HAVE NOT MENTION THE LAST NAME THAT'S WHY WE GOT THE ERROR. ALSO WE HAVE NOT SET ANY DEFALUT VALUE FOR THAT ALSO.
# TO INSERT THIS,WRITE FIRST_NAME.
INSERT INTO CUSTOMER_INFO_2(ID,FIRST_NAME,LAST_NAME,AGE,ADDRESS,LOCATION,PHONE_NUMBER) VALUES (9,"ADITYA","JOSHI",25,"#105 LAXMI NAGAR NAGPUR",
"MAHRASHTAR",9433995329)

INSERT INTO CUSTOMER_INFO_2 VALUES (10,"SAYALI","JOSHI",30,"#106 JP NAGAR NAGPUR",NULL,9423939319)

SELECT * FROM CUSTOMER_INFO_2

# TO RESOLVE ALL THE ABOVE ERRORS, CONSTRANITS ARE VERY VERY IMP. 

 SHOW TABLES;
 
 # 1 MILLION = 10 LAKHS
 # 1 BILLION = 100 CR

												 # WE INSERTED CAR DATA IN MYSQL IN FLIPKART_DB FROM EXCEL.
                                                             
                                                             
# Q. HOW MANY TOTAL CARS ARE IN TABLE?                                                            															
SELECT * FROM CAR_DATA                                        # THIS SHOW ALL RECORDS. (* MEANS EVERYTHING)
SELECT COUNT(*) FROM CAR_DATA;
SELECT CAR_NAME,YEAR,KMS_DRIVEN,SELLING_PRICE FROM CAR_DATA;  # THIS SHOW WHAT WE WANT ONLY (SELECTED COLUMNS)

# Q. HOW MANY TOTAL CARS ARE IN TABLE IN YEAR=2016?   
SELECT * FROM CAR_DATA WHERE YEAR=2016;
SELECT COUNT(*) FROM CAR_DATA WHERE YEAR=2016;

# AND
# Q. COUNT OF DISEAL CAR IN 2015?
SELECT * FROM CAR_DATA WHERE YEAR=2015 AND FUEL_TYPE='DIESEL';
SELECT COUNT(*) FROM CAR_DATA WHERE YEAR=2015 AND FUEL_TYPE='DIESEL';

# ORDER BY
# Q.SHOW ALL DATA IN ASCE/DESC ORDER BY KMS_DRIVEN?
SELECT * FROM CAR_DATA ORDER BY KMS_DRIVEN;          # BY DEFAULT ITS SORTING IN ASCE
SELECT * FROM CAR_DATA ORDER BY KMS_DRIVEN DESC;

# ORDER BY ON 2 COLUMNS
SELECT * FROM CAR_DATA ORDER BY Fuel_Type ASC, KMS_DRIVEN DESC;

# IN
# Q. SHOW ALL DATA FROM YEAR 2014 AND 2015?
SELECT * FROM CAR_DATA WHERE YEAR IN (2014,2015);

# Q. COUNT OF CAR FROM YEAR 2014 AND 2015?
SELECT COUNT(*) FROM CAR_DATA WHERE YEAR IN (2014,2015);
SELECT * FROM CAR_DATA WHERE YEAR IN (2014,2015,2016,2017,2018)ORDER BY YEAR;
SELECT * FROM CAR_DATA WHERE YEAR IN (2014,2015,2016,2017,2018)ORDER BY YEAR DESC;
SELECT * FROM CAR_DATA ORDER BY YEAR;

# '<' or '>' or '='
# Q. SHOW ALL DATA WHOES KMS_DRIVEN IS 'LESS THAN' / 'GREATER THAN' / '=' 10000;
SELECT * FROM CAR_DATA WHERE KMS_DRIVEN > 10000;
SELECT COUNT(*) FROM CAR_DATA WHERE KMS_DRIVEN > 10000;

SELECT * FROM CAR_DATA WHERE KMS_DRIVEN < 10000;
SELECT COUNT(*) FROM CAR_DATA WHERE KMS_DRIVEN < 10000;

SELECT * FROM CAR_DATA WHERE KMS_DRIVEN = 10000;
SELECT COUNT(*) FROM CAR_DATA WHERE KMS_DRIVEN = 10000;


# BETWEEN
# Q. SHOW ALL DATA FROM YEAR 2005 TO 2015?
SELECT * FROM CAR_DATA WHERE YEAR BETWEEN 2005 AND 2015;
SELECT COUNT(*) FROM CAR_DATA WHERE YEAR BETWEEN 2005 AND 2015; # HERE 2005 AND 2015 ARE INCLUDED

# Q. SHOW ALL DATA FROM YEAR 2010 TO 2015?
SELECT * FROM CAR_DATA WHERE YEAR BETWEEN 2010 AND 2015;
SELECT COUNT(*) FROM CAR_DATA WHERE YEAR BETWEEN 2010 AND 2015

# '> AND <' OR  '< AND >' 
# Q. SHOW ALL DATA OF CAR > 2010 AND < 2015  LESS TAHN 2010 & GREATER THAN 2015
SELECT * FROM CAR_DATA WHERE YEAR > 2010 AND YEAR < 2015 ;  # HERE 2010 AND 2015 BOTH ARE EXCLUDED.
SELECT COUNT(*) FROM CAR_DATA WHERE YEAR > 2010 AND YEAR < 2015 ;

SELECT * FROM CAR_DATA WHERE YEAR >= 2010 AND YEAR <= 2015 ;  # HERE 2010 AND 2015 BOTH ARE INCLUDED.
SELECT COUNT(*) FROM CAR_DATA WHERE YEAR >= 2010 AND YEAR <= 2015 ;

# NOT IN
# Q. SHOW ALL DATA FROM ALL YEAR EXCEPT(2003,2004,2005,2008)
SELECT * FROM CAR_DATA WHERE YEAR NOT IN (2003,2004,2005,2008);
SELECT COUNT(*) FROM CAR_DATA WHERE YEAR NOT IN (2003,2004,2005,2008);

# SHOW ME ALL CARS FROM 2007 TO 2015 (EXCLUDIND 2008)?   V.V.IMP
SELECT * FROM CAR_DATA WHERE YEAR BETWEEN 2007 AND 2015 AND YEAR NOT IN (2008);
SELECT COUNT(*) FROM CAR_DATA WHERE YEAR BETWEEN 2007 AND 2015 AND YEAR NOT IN (2008);

# WHAT IS THE FIRST MODEL CAR AND WHAT IS THE LATEST MODEL CAR?
 SELECT MIN(YEAR) FROM CAR_DATA; # 1ST CAR
 SELECT MAX(YEAR) FROM CAR_DATA; # LATEST CAR
 
 # WHAT IS THE MAX KMS AND MIN KMS DRIVEN
 SELECT MAX(KMS_DRIVEN) FROM CAR_DATA;
 SELECT MIN(KMS_DRIVEN) FROM CAR_DATA;
 
 # DISTINCT     [ IT WILL COUNT THINGS ONLY ONCE NOT FOR REPEATED TIMES ]
 # HOW MANY YEARS ARE PRESENT IN COMPLETE DATA SET BUT ?
 SELECT COUNT(YEAR) FROM CAR_DATA;
 SELECT COUNT(DISTINCT(YEAR)) FROM CAR_DATA;
 
 SELECT DISTINCT(FUEL_TYPE) FROM CAR_DATA;
 
 # LIKE/NOT LIKE
 # 1. LIKE
 
 # SHOW ME ALL THE CARS WHOSE NAME STARTS WITH THE 'S'.
 SELECT * FROM CAR_DATA WHERE CAR_NAME LIKE "S%";
 SELECT DISTINCT(CAR_NMAE) FROM CAR_DATA WHERE CAR_NAME LIKE "S%";
 
 # SHOW ME ALL THE CARS WHOSE NAME END WITH THE 'A'.
 SELECT * FROM CAR_DATA WHERE CAR_NAME LIKE "%A";
 
 # 2. NOT LIKE
 # SHOW ME ALL THE DATA WHOES NAME DOESN'T START FROM 'S'.
  SELECT * FROM CAR_DATA WHERE CAR_NAME NOT LIKE "S%";
  
# SHOW ME ALL THE DATA WHOES NAME DOESN'T ENDS WITH'S'.
 SELECT * FROM CAR_DATA WHERE CAR_NAME NOT LIKE "%S";
 
 # V. V. IMP [ GROUP BY ]
 
 # WE CAN'T PUT ANY 'WHERE' CONDITION AFTER THE 'GROUP BY' CLAUSE. BUT WITH HELP OF 'HAVING' CONDITION WE CAN FILTTER DATA. WE WILL SEE WHAT 
 # IS 'HAVING' CLAUSE IN FUTURE.
# HOW MANY CARS ARE THERE IN 2005?
SELECT COUNT(CAR_NAME) FROM CAR_DATA WHERE YEAR=2005;
# HOW MANY CARS ARE THERE IN 2006?
SELECT COUNT(CAR_NAME) FROM CAR_DATA WHERE YEAR=2006;
# HOW MANY CARS ARE THERE IN 2007?
SELECT COUNT(CAR_NAME) FROM CAR_DATA WHERE YEAR=2007;
# HOW MANY CARS ARE THERE IN 2008?
SELECT COUNT(CAR_NAME) FROM CAR_DATA WHERE YEAR=2008;
# HOW MANY CARS ARE THERE IN 2015?
SELECT COUNT(CAR_NAME) FROM CAR_DATA WHERE YEAR=2015;

# WRITING THIS QUERY FOR EVERY YEAR IS TO LEANTHY SO WRITE THE FOLLOWING QUERY.

# IF WE WRITE THE ANY 'COLUMN' NAME BEHIND THE 'AGGRIGATE' FUNCTION i.e.COUNT MAX MIN SUM ETC... THEN WRITE ' GROUP BY ' COMMAND IN QUERY AND AFTER GROUP  
# BY, WRITE THAT COLUMN NAME.
 SELECT YEAR,COUNT(CAR_NAME) FROM CAR_DATA GROUP BY YEAR;
 SELECT YEAR,COUNT(CAR_NAME) FROM CAR_DATA GROUP BY YEAR ORDER BY YEAR;
 
 # NOW HOW MANY CARS ARE THEIR IN 2017?
 # NOW HOW MANY PETROL CARS ARE THEIR IN 2017? 
 # NOW HOW MANY DIESEL CARS ARE THEIR IN 2017?
SELECT COUNT(CAR_NAME) FROM CAR_DATA WHERE YEAR=2017;
SELECT COUNT(CAR_NAME) FROM CAR_DATA WHERE YEAR=2017 AND FUEL_TYPE="PETROL";
SELECT COUNT(CAR_NAME) FROM CAR_DATA WHERE YEAR=2017 AND FUEL_TYPE="DIESEL";
# INSTED OF WRITING DIFFERENT QUERY FOR DIFFERENT QUESTION WRITE THE FOLLOWING STD. QUERY.


SELECT YEAR,FUEL_TYPE,COUNT(CAR_NAME) FROM CAR_DATA 
GROUP BY YEAR, FUEL_TYPE 
ORDER BY YEAR;    

SELECT * FROM CAR_DATA;

# WE HAVE IMPORTED ELE_STORE1 DATA 
SELECT * FROM ELE_STORE1

# TOTAL SALES MADE BY CHINA/INDIA/RUSSIA?
SELECT SUM(SALES) FROM ELE_STORE1 WHERE COUNTRY="CHINA";
SELECT SUM(SALES) FROM ELE_STORE1 WHERE COUNTRY="INDIA";
SELECT SUM(SALES) FROM ELE_STORE1 WHERE COUNTRY="RUSSIA";

# TOTAL AVG SALES MADE BY CHINA/INDIA/RUSSIA?
SELECT AVG(SALES) FROM ELE_STORE1 WHERE COUNTRY="CHINA";
SELECT AVG(SALES) FROM ELE_STORE1 WHERE COUNTRY="INDIA";
SELECT AVG(SALES) FROM ELE_STORE1 WHERE COUNTRY="RUSSIA";

SELECT COUNTRY,SUM(SALES) FROM ELE_STORE1 GROUP BY COUNTRY;

# HOW MUCH SALES COMING FROM EACH CHANNELS IN INDIA?
SELECT CHANNEL,SUM(SALES) FROM ELE_STORE1
WHERE COUNTRY="INDIA"
GROUP BY CHANNEL;

# HOW MUCH SALES COMING FROM EACH CHANNEL IN CHINA?
SELECT CHANNEL,SUM(SALES) FROM ELE_STORE1
WHERE COUNTRY="CHINA"
GROUP BY CHANNEL;

# TOTAL NO. OF ORDERS PLACED BY EACH AND EVERY COUNTRY.
SELECT COUNTRY,COUNT(ORDERID) FROM ELE_STORE1 
GROUP BY COUNTRY
ORDER BY COUNTRY;
#     OR 
# ORDER BY COUNTRY DESC;
#     OR
# ORDER BY COUNT(ORDERID)DESC/DESC;

SELECT * FROM ELE_STORE1

# Q. IN INDIA WHICH CITY GIVES US HOW MUCH SALES ?
SELECT CITY, SUM(SALES) FROM ELE_STORE1 
WHERE COUNTRY = " INDIA " 
GROUP BY CITY
ORDER BY CITY;


SELECT * FROM ELE_STORE1
# WHICH PRODUCTCATEGORY IS GIVING MAX SALES BETWEEN THEM?
SELECT PRODUCTCATEGORY,SUM(SALES) FROM ELE_STORE1 
GROUP BY PRODUCTCATEGORY 
ORDER BY SUM(SALES)DESC;

SELECT * FROM ELE_STORE1
# WHAT IS THE TOTAL NO OF QUANTITY PURCHASE ACCROS DIFFERENT REGION.
SELECT REGION,SUM(ORDERQTY) FROM ELE_STORE1 
GROUP BY REGION 
ORDER BY SUM(ORDERQTY)DESC;

## AGAIN WE WILL WORK ON CAR_DATA
SELECT * FROM CAR_DATA;

# 'HAVING' CLAUSE     
# THIS WILL USE ONLY WHEN WHEN WE HAVE TO DRAW SOME CONDITIONAL DATA (SPRCIFIC DATA) FOR THAT AFTER ' HAVING ' WE CAN WRITE SOME CONDITION.

# Q. WHICH YEARS HAVE MORE THAN 25 CARS?
SELECT YEAR,COUNT(CAR_NAME) FROM CAR_DATA 
GROUP BY YEAR
HAVING COUNT(CAR_NAME)>25;

# WHAT IS THE DIFFERENCE BETWEEN 'WHERE' CLAUSE AND 'HAVING' CLAUSE?

# ANS:- WHERE CLAUSE MEANS, IN ORDER TO FILTTER ACTUAL COLUMNS OF DATA WE CAN GO WITH "WHERE" CLAUSE; 
# HAVING CLAUSE MEANS, IN ORDER TO PUT FILTER ON AGGRIGATION APPLIED COLUMN AND ON DERIVED COLUMN IN THE QUERY , WE WILL USE "HAVING" CLAUSE.
# WE USE 'HAVING' CLAUSE ONLY AFTER THE 'GROUP BY' CLAUSE. IN SHORT WE CAN SAY THAT HAVING CLAUSE IS DEPENDANT CLAUSE (DEPEND ON "GROUP BY" CLAUSE).
# BUT IN SOME CASESES WE CAN USE HAVING CLAUSE WITHOUT GROUP BY ALSO , WHEN WE CALCULATE DERIVED COLUMN, AND IF WE WANT TO APPLY ANY CONDTION ON THAT 
# THEN WE USE HAVING CLAUSE.

# [ " AGAIN WE WILL WORK ON ELE_STORE1 DATA " ]

SELECT * FROM ELE_STORE1;
# SHOW ME ALL THE COUNTRIES WHOSE TOTAL SALES IS GREATER THAN 500000
# 1ST WAY-->
SELECT COUNTRY,SUM(SALES) FROM ELE_STORE1
GROUP BY COUNTRY
HAVING SUM(SALES)>500000
ORDER BY SUM(SALES);
#     OR
# ORDER BY COUNTRY;

# 2ND WAY---->  WITH HELP OF ALIAS 'AS' WHATEVER THE NAME WE HAVE GIVEN WE CAN USE FURTHER. IN 'HAVING' CLAUSE or IN 'ORDER BY' CLAUSE.
SELECT COUNTRY,SUM(SALES)AS TOTAL_SALES FROM ELE_STORE1
GROUP BY COUNTRY
HAVING TOTAL_SALES >500000
ORDER BY TOTAL_SALES ;

# SHOW ME THE SALES ABOVE 50000 BY PRODUCTCATEGORY IN INDIA?
SELECT PRODUCTCATEGORY,SUM(SALES) FROM ELE_STORE1
WHERE COUNTRY="INDIA"
GROUP BY PRODUCTCATEGORY
HAVING SUM(SALES)>50000
ORDER BY SUM(SALES);

SELECT * FROM ELE_STORE1;
DESCRIBE ELE_STORE1;


# "DESCRIBE"
# IF WE WANT TO SEE THE STRUCTURE OF THE TABLE SOMEONE WHO HAVE ALLREADY CREATED THEN WE CAN USE "DESCRIBE".

DESCRIBE ELE_STORE1;
DESCRIBE CAR_DATA;
DESCRIBE CUSTOMER_INFO_2;

SELECT * FROM ELE_STORE1;
# WHAT IS THE DATE WHEN 1ST AND LAST SALE WAS HAPPEN ?
SELECT MIN(ORDERDATE) FROM ELE_STORE1;# 01-01-2018
SELECT MAX(ORDERDATE) FROM ELE_STORE1; # 31-12-2057

# HOW MUCH SALE IS HAPPENING IN 2016/2017/2018/2019 ?

# 1ST SEE THE DATA HOW IT IS.
SELECT * FROM ELE_STORE1;
# NOW AFTER LOOKING INTO THE DATA WE GOT ONE THING THAT IN THIS DATA, SEPERATE 'YEAR' COLUMN IS NOT THERE.

# NOW IF RUN THE FOLLOWING QUERY THEN WE WILL GET THE SUM OF SALES W.R.T. DATE.
SELECT ORDERDATE , SUM(SALES) FROM ELE_STORE1 
GROUP BY ORDERDATE
ORDER BY ORDERDATE ;

# BUT OUR QUESTION IS ----> HOW MUCH SALE IS HAPPENING IN 2016/2017/2018/2019 ?

# 1ST WE WILL SEE THE DATA.
SELECT * FROM ELE_STORE1;
# AFTER THAT SEE THE DISCRIPTION OF THE DATA.
DESCRIBE ELE_STORE1;

# AFTER WATCHING IT WE GOT ONE THING THAT DATE HAS WRONG DATATYPE IT IS IN TEXT DATATYPE BUT IT SHOULD BE DATE/DATETIME/TIMESTAMP ETC.
# SO TO FIX THIS ISSUE DO THE FOLLOWING STEPS.

# EITHER WE CAN CHANGE THE DATA TYPE WITH THE HELP OF 'ALTER COMMAND' OR WE WILL WRITE THE FOLLOWING QUERY.
SELECT SUBSTR(ORDERDATE,7,10) AS YEAR,
SUM(SALES)
FROM ELE_STORE1
GROUP BY YEAR
ORDER BY YEAR;

#########################################################################################################################################################################

# THIS FOLLOWING CODE WILL EXECUTE WHEN 'DATE' IS HAVING "DATE/DATETIME/TIMESTAMP" etc. DATATYPE. 
# WE CAN EXTRACT SOME INFO. FROM THE COLUMN WITH 'EXTRACT' FUNCTION.

#OUR QUESTION IS ----> HOW MUCH SALE IS HAPPENING IN 2016/2017/2018/2019 ?

SELECT ORDERDATE,EXTRACT(YEAR FROM ORDERDATE),
EXTRACT(MONTH FROM ORDERDATE)
FROM ELE_STORE1;

# ANS OF OUR QUERY --->
# AFTER EXECUTING THIS QUERY WE WILL GET YEAR WISE SUM OF SALES.
SELECT EXTRACT(YEAR FROM ORDERDATE),SUM(SALES) FROM ELE_STORE1
GROUP BY EXTRACT(YEAR FROM ORDERDATE)
ORDER BY EXTRACT(YEAR FROM ORDERDATE);


# Q. WHICH MONTH HAS GIVIN ME A MAX SALES IN PERTICULAR YEAR I.E. OUT OF THESE (2016-2017 OR 2017-2018 OR 2018-2019) 3 YEAR ( 36 MONTHS ) ? 
# EITHER IT IS JAN-2018 OR MAR-2017 OR NOV-2018 LIKE TAHT.

# 1ST WE WILL SE THE DATA.
SELECT * FROM ELE_STORE1;

# THIS FOLLOWING CODE WILL EXECUTE WHEN 'DATE' IS HAVING "DATE/DATETIME/TIMESTAMP" etc. DATATYPE. 

# ACTUAL QUERY---->
SELECT 
EXTRACT(YEAR FROM ORDERDATE) YR,
EXTRACT(MONTH FROM ORDERDATE) MNTH,
SUM(SALES)TOTAL_SALES
FROM ELE_STORE1
GROUP BY YR,MNTH
ORDER BY TOTAL_SALES DESC;

# OR 
SELECT 
SUBSTR(ORDERDATE,7,10) YR,
SUBSTR(ORDERDATE,4,5 ) MNTH,
SUM(SALES)TOTAL_SALES
FROM ELE_STORE1
GROUP BY YR,MNTH
ORDER BY TOTAL_SALES DESC;

															 # 'JOINS'  [ V.V.V.IMP ]

DROP TABLE IF EXISTS CUSTUMER_TB;

CREATE TABLE CUSTUMER_TB 
(
ID INT,
NAME VARCHAR(20),
AGE TINYINT,
ADDRESS VARCHAR(50),
WALLET_BAL FLOAT
);
SELECT * FROM CUSTUMER_TB ;

INSERT INTO CUSTUMER_TB VALUES (1, "RAMESH", 32, "ADMEDABAD", 200);
INSERT INTO CUSTUMER_TB VALUES (2, "KHILAN", 23, "DELHI", 7500);
INSERT INTO CUSTUMER_TB VALUES (3, "KAUSHIK", 25, "KOTA", 12000);
INSERT INTO CUSTUMER_TB VALUES (4, "CHAITALI", 22, "MUMBAI", 6500);
INSERT INTO CUSTUMER_TB VALUES (5, "HARDIK", 27, "BHOPAL", 6500);
INSERT INTO CUSTUMER_TB VALUES (6, "KOMAL", 26, "MP", 750);
INSERT INTO CUSTUMER_TB VALUES (7, "MUFFY", 27, "INDORE", 500);

DROP TABLE IF EXISTS ORDER_TB;

CREATE TABLE ORDER_TB
 (
OID INT,
DATE DATE,
C_ID INT,
AMOUNT FLOAT
);

INSERT INTO ORDER_TB VALUES (102, "2009-10-08", 3, 3000);
INSERT INTO ORDER_TB VALUES (100, "2009-10-08", 3, 1500);
INSERT INTO ORDER_TB VALUES (101, "2009-11-20", 2, 1560);
INSERT INTO ORDER_TB VALUES (103, "2008-05-20", 4, 2060);
INSERT INTO ORDER_TB VALUES (199, "2020-05-20", NULL ,9999);

# 'QUERY' INSIDE THE 'QUERY' IS CALLED "SUBQUERY".

# HOW MANY CUSTOMERS HAVE PURCHASED ANY OF THE PRODUCT AND HOW MANY DON'T ? 

SELECT * FROM CUSTOMER_TB WHERE ID IN (SELECT DISTINCT(C_ID) FROM ORDER_TB);

SELECT * FROM CUSTUMER_TB;
SELECT * FROM ORDER_TB;

DESCRIBE ORDER_TB;
DESCRIBE CUSTUMER_TB;

# I WANT INFO FROM BOTH TABLE I.E. I WANT 2 COLUMN FROM CUSTOMER TABLE AND 2 COLUMN FROM ORDER TABLE.

# "INNER JOIN"
---------------
# IF WE USE "INNER JOIN",INNER JOIN SHOULD MATCH AT LEAT ONE COLUMN FROM BOTH TABLES.
# IF WE USE THIS 'INNER JOIN' THEN WE ARE NOT GETTING ANS OF THE FOLLOWING Q.
# Q1. HOW MANY TOTAL CUTOMERS ARE THERE ? AND Q2.HOW MANY DON'T HAVE PURCHASE ANY THING?

# SO FOR THE ABOVE PROBLEM WE HAVE SOLUTION I.E. WITH THE HELP OF "LEFT JOIN" WE CAN RESOLVE OUR PROBLEM.
																  ------------
# "LEFT JOIN"
--------------
# BUT WE WILL NOT GET THE INFO. OF THAT CANDIDATE WHO HAS NO ACC. BUT HE PURCHASED WITH 'DIRECT PURCHASE OPTION'. 


# SO FOR ABOVE PROBLEM WE HAVE SOLUTION I.E. RIGHT JOIN.
# "RIGHT JOIN".
---------------
# IF ANY CANDIDATE IS NOT HAVING ACC. BUT STILL HE/SHE PURCHSE ANY THING BY DIRECT PURCHSE OPTION THEN TAHT RECORD WILL NOT GET WITH "LEFT JOIN" 
# SO FOR THAT WE USE "RIGHT JOIN".


# FULL JOIN = 'LEFT JOIN' + 'RIGHT JOIN'.  BUT DON'T USE THIS. IT WILL GIVES US HUGE AMT. DATA. SOME TIME IT IS DIFICULT TO HANDEL.IT MIGHT GET
# EXPLODE.
# ------------                       -----------                         -------------                    ----------------

 
# ACTUAL IMPLEMENTATION.

 # 1ST WE WILL REVISE SOME THINS.
 
 USE FLIPKART_DB;

SELECT * FROM CAR_DATA;
#         OR
SELECT * FROM FLIPKART_DB.CAR_DATA;  #[ HERE WE ARE ACCESSING TABLE FROM DATABASE BY PUUTING DATABASE NAME 1ST THEN TABLE NAME.]
#         OR
SELECT CAR_NAME,YEAR,SELLING_PRICE,PRESENT_PRICE,KMS_DRIVEN,FUEL_TYPE,SELLER_TYPE,TRANSMISSION FROM CAR_DATA;

# IF WE WANT ONLY FEW COLUMNS FROM TABLE THEN ALSO WE CAN DRAW THOSE COLUMNS.
SELECT CAR_NAME,YEAR,PRESENT_PRICE,KMS_DRIVEN,FUEL_TYPE,TRANSMISSION FROM CAR_DATA;

SELECT CAR_DATA.CAR_NAME, CAR_DATA.KMS_DRIVEN, CAR_DATA.SELLING_PRICE FROM CAR_DATA; # [ HERE WHAT WE HAVE DONE SEE--> WE WROTE 1ST TABLE NAME THEN 
#  WE WROTE COLUMN NAME. AS WE HAVE DONE SAME PROCEDURE IN ABOVE ALSO, WHILE ACCESSING THE TABLE FROM DATA BASE I.E. 1ST WE WROTE DATABASE NAME THEN
# TABLE NAME.]
# [ 1ST CASE--->( DATABASE_NAME.TABLE_NAME ) |||||   2ND CASE---->( TABLE_NAME.COLUMN_NAME ) ]

# SAME CODE WITH ALISA IE WITH 'AS'
SELECT A.CAR_NAME,A.KMS_DRIVEN,A.SELLING_PRICE FROM CAR_DATA AS A ;
# [ HERE WE CAHNGE THE NAME OF TABLE FROM 'CAR_DATA' TO 'A' ] AND HERE WE HAVE DONE SAME THING AS ABOVE ----> (TABLE_NAME.COLUMN_NAME) BUT HERE 
# TABLE NAME IS 'A'. AS WE HAVE CHANGED THE NAME BY GIVING ALIAS I.E. 'AS'. ( ===>A.CAR_NAME )


# NOW HERE WE WILL START ACTUAL IMPLEMENTATION OF 'JOIN' OPERATIONS.

# FOR THAT WE WILL USE CUSTOMER_TB AND ORDER_TB.
# 1ST WE WILL SEE THE TABEL;
SELECT * FROM CUSTUMER_TB;
SELECT * FROM ORDER_TB;

# 'INNER JOIN'
# Q1. COMPLETE DETAILS OF THE CUSTMER FROM AMAZON,THOSE WHO PURCHASED ANY THING FROM AMAZON?
SELECT A.NAME,A.ADDRESS,B.OID,B.DATE  FROM CUSTOMER_TB AS A
INNER JOIN
ORDER_TB AS B
ON A.ID=B.O_ID;

# Q1.1 HOW MANY CUSTOMERS ARE THEIR IN AMAZON,THOSE WHO PURCHASED ANY THING FROM AMAZON? ( TELL US COUNT ?)
SELECT COUNT(DISTINCT(NAME)) FROM CUSTOMER_TB AS A
INNER JOIN
ORDER_TB AS B
ON A.ID=B.O_ID;


SELECT * FROM CUSTUMER_TB;
SELECT * FROM ORDER_TB;

# 'LEFT JOIN' [ TABLE PRESENT BEHIND THE 'LEFT JOIN' IS "LEFT TABLE" AND AFTR 'LEFT JOIN'  IS "RIGHT TABLE"]
# Q1.COMPLETE DETAILS OF THE CUSTMER FROM AMAZON?
SELECT A.NAME,A.ADDRESS,B.OID,B.DATE FROM CUSTOMER_TB AS A
LEFT JOIN
ORDER_TB AS B
ON A.ID=B.O_ID;

# Q1.1 HOW MANY CUSTMERS ARE THEIR IN AMAZON? ( TELL US COUNT ? )
SELECT COUNT(DISTINCT(NAME)) FROM CUSTOMER_TB AS A
LEFT JOIN
ORDER_TB AS B
ON A.ID=B.O_ID;

# Q2. HOW MANY CUSTOMER BUY,ANY THING FROM AMAZON?
SELECT COUNT(DISTINCT(NAME)) FROM CUSTOMER_TB AS A
LEFT JOIN
ORDER_TB AS B
ON A.ID=B.O_ID
WHERE O_ID IS NULL;     # IMP [ INSTED OF "=" WE HAVE TO WRITE "IS" ]

# Q2.1.HOW MANY CUSTOMER DIDN'T BUY,ANY THING FROM AMAZON?
SELECT COUNT(DISTINCT(NAME)) FROM CUSTOMER_TB AS A
LEFT JOIN
ORDER_TB AS B
ON A.ID=B.O_ID
WHERE O_ID IS NOT NULL;     #IMP



SELECT * FROM CUSTUMER_TB;
SELECT * FROM ORDER_TB;
# RIGHT JOIN   [ TABLE PRESENT BEHIND THE 'RIGHT JOIN' IS "LEFT TABLE" AND AFTR 'LEFT JOIN' IS "RIGHT TABLE" ]

#Q.1 GIVE ME THE COMPLETE DETAILS OF WHICH PRODUCT BOUGHT BY WHICH CUSTOMER ?
SELECT A.NAME,A.ADDRESS,B.OID,B.DATE  FROM CUSTOMER_TB AS A
LEFT JOIN
ORDER_TB AS B
ON A.ID=B.O_ID;

# Q.2 HOW MANY CUSTOMERS ARE THE GUEST CUSTOMERS?
SELECT A.NAME,A.ADDRESS,B.OID,B.DATE  FROM CUSTOMER_TB AS A
LEFT JOIN
ORDER_TB AS B
ON A.ID=B.O_ID
WHERE A.NAME IS NULL;


DESCRIBE ORDER_TB;
DESCRIBE CUSTUMER_TB;


# 'FULL JOIN'
# NO SYNTAX IS PRESENT IN MYSQL FOR "FULL JOIN".
# WE HAVE DIFFERNET WAY TO RUN THIS CODE IN MYSQL.
## WE CAN RUN THIS CODE IN ALL OTHER SQL PLATFORM.


## BEFORE MOVING TO THE 'FULL JOIN' LET US SEE WHAT IS UNION/UNION ALL.

# "UNION" AND "UNION ALL"   # V.V.IMP INTERVIEW QUESTION ----> WHAT IS THE DIFFERENCE BETWEEN UNION AND UNION ALL ?

# "UNION" AND "UNION ALL" IS FUNCTION OR METHOD TO APPEND THE DATA ROW BY ROW IN SQL.
# CONDITIONS:-
# WHILE USING 'UNION' OPERATION SAME NO. OF COLUMNS MUST BE PRESENT.     
# WHILE USING 'UNION' OPERATION ORDER OF COLUMN MUST BE SAME.
# WHILE USING 'UNION' OPERATION COLUMNS MUST HAVE SIMILAR DATA TYPES.


# "UNION"-------> MEANS UPDATING 1ST TABLE WITH HELP OF 2ND, WITHOUT DUPLICACY.
# "UNION" OPERATION TAKES MUCH TIME TO EXECUTE THE QUERY. 1ST STEP IS COMBINE THE DATA AND THEN 2ND STEP IS REMOVING THE DUPLICATES.

# "UNION ALL"---> MEANS UPDATING 1ST TABLE WITH HELP OF 2ND WITH DUPLICACY.
# "UNION AL" OPERATION TAKES LESS TIME THAN "UNION" TO EXECUTE THE QUERY. HERE ONLY ONE STEP IS PRESENT COMBINE THE DATA.
 
 CREATE TABLE QTR1
 (
 MONTH VARCHAR(20),
 SALES INT 
 );
INSERT INTO QTR1 VALUES('JAN',2500);
INSERT INTO QTR1 VALUES('FEB',7500);
INSERT INTO QTR1 VALUES('MAR',4500);


  CREATE TABLE QTR2
 (
 MONTH VARCHAR(20),
 SALES INT 
 );
INSERT INTO QTR1 VALUES('MAR',4500);
INSERT INTO QTR1 VALUES('APR',1500);
INSERT INTO QTR1 VALUES('MAY',8500);
INSERT INTO QTR1 VALUES('JUN',6000);
 
SELECT * FROM QTR1;
SELECT * FROM QTR2;
 
# UNION
SELECT * FROM QTR1
UNION
SELECT * FROM QTR2;

# UNION ALL
SELECT * FROM QTR1
UNION ALL
SELECT * FROM QTR2;


# FULL JOIN CODE [ 'LEFT JOIN' + 'UNION'/'UNION ALL' + 'RIGHT JOIN' ]
SELECT A.NAME,A.ADDRESS,B.OID,B.DATE  FROM CUSTOMER_TB AS A
LEFT JOIN
ORDER_TB AS B
ON A.ID=B.O_ID
UNION 
SELECT A.NAME,A.ADDRESS,B.OID,B.DATE  FROM CUSTOMER_TB AS A
RIGHT JOIN
ORDER_TB AS B
ON A.ID=B.O_ID;



# SELF JOIN TABLE [ JOIN TABLE WITH SAME TABLE ]. VVVV IMP.

DROP TABLE EMP_MGR;
 CREATE TABLE EMP_MGR
 (
 ID INT,
 F_NAME VARCHAR(20),
 L_NAME VARCHAR(20),
 M_ID INT
 );
 
 INSERT INTO EMP_MGR VALUES(1,'JOE','ALAN', NULL);
 INSERT INTO EMP_MGR VALUES(2,'KIRAN','KUMAR',4);
 INSERT INTO EMP_MGR VALUES(3,'DINESH','RAJA',6);
 INSERT INTO EMP_MGR VALUES(4,'SATISH','R',5);
 INSERT INTO EMP_MGR VALUES(5,'DIVYA','J',6);
 INSERT INTO EMP_MGR VALUES(6,'HEMA','IRANI',1);
 
SELECT * FROM EMP_MGR;
SELECT ID,F_NAME, M_ID FROM EMP_MGR;
# ??
# TELL ME THE MANAGER'S NAME OF EACH EMPLOYES ?
 SELECT A.F_NAME AS EMP_NAME, B.F_NAME AS MANAGER_NAME FROM 
 EMP_MGR AS A LEFT JOIN EMP_MGR AS B                         # VVVV IMP.
 ON B.ID=A.M_ID;  
 
 # WHY WE PUT M_ID IS ON RIGHT SIDE OF THE '=' NOT ON LEFT SIDE OF '=',  BECAUSE WE WANT MANAGER NAME FOR THE RESPECTIVE EMPLOYEE NAME.
 USE FLIPKART_DB;
# CROSS JOIN  [ NOT THAT MUCH USE IN REAL TIME DATA ] 
# CROSS JOIN [ HOW MANY COMBINATIONS ARE AVAILABLE FOR 'IDELY' TO EAT WITH 'SIDE DISH'. SIMILARLY WITH DOSA AND POORI ]
# SO TO ANS FOR THIS Q. WE HAVE TO USE CROSS JOIN. WHICH IS AS BELOW.
 
  CREATE TABLE T1
  (
  BREAKFAST VARCHAR(20)
  );
  
INSERT INTO T1 VALUES('IDLY');
INSERT INTO T1 VALUES('DOSA');
INSERT INTO T1 VALUES("POORI");
  
SELECT * FROM T1;
  
  CREATE TABLE T2
  (
  SIDE_DISH VARCHAR(20)
  );
    
INSERT INTO T2 VALUES('CHANTEY');
INSERT INTO T2 VALUES('SAMBHAR');
INSERT INTO T2 VALUES("CURRY");
 
SELECT * FROM T2;
   
 SELECT A.BREAKFAST,B.SIDE_DISH FROM T1 AS A 
 INNER JOIN T2 AS B;
# OTHER EXP.

# VEHICLE                    COLOR

# 2 WHEELER                  BLACK
# 4 WHEELER                  WHITE
#                            BLUE

# 'OTHER EXP' 

#STUDENT                     SUBJECT
# A                           MATHS
# B                          SCIENCE
# C
# D
# E
 
 # HOW MANY JOIN CONDITIONS ARE REQUIRED TO JOIN N TABLES. (N-1)
 # EX. 432 TABLES ARE THERE. SO NO OF JOIN CONDITIONS ARE 432-1= 431
 
 # MULTIPLE TABLES JOINS
 
SELECT * FROM CUSTUMERTB;
SELECT * FROM ORDERTB;
SELECT * FROM PRODUCTTB;

DROP TABLE CUSTUMERTB;
CREATE TABLE CUSTUMERTB
(
ID INT,
NAME VARCHAR(20),
LOCATION VARCHAR(20)
);
INSERT INTO CUSTUMERTB VALUES (1,'KIRAN','MUM');
INSERT INTO CUSTUMERTB VALUES (2,'GIRI','CHE');
INSERT INTO CUSTUMERTB VALUES (3,'RAHUL','HYD');

DROP TABLE ORDERTB;
CREATE TABLE ORDERTB
(
OID INT,
CID INT,
PID VARCHAR(20),
PRICE INT
);
INSERT INTO ORDERTB VALUES (101,1,'P1',1000);
INSERT INTO ORDERTB VALUES (102,1,'P2',2000);
INSERT INTO ORDERTB VALUES (105,2,'P1',1000);
INSERT INTO ORDERTB VALUES (106,2,'P2',2000);
INSERT INTO ORDERTB VALUES (106,2,'P2',2000);
INSERT INTO ORDERTB VALUES (106,2,'P3',2400);
INSERT INTO ORDERTB VALUES (106,3,'P2',2000);

DROP TABLE PRODUCTTB;
CREATE TABLE PRODUCTTB
(
PID VARCHAR(20),
PNAME VARCHAR(20)
);
INSERT INTO PRODUCTTB VALUES ('P1','VIVO');
INSERT INTO PRODUCTTB VALUES ('P2','IPHONE');
INSERT INTO PRODUCTTB VALUES ('P3','SAMSUNG');

SELECT A.NAME,C.PNAME,B.PRICE FROM 
CUSTUMERTB AS A LEFT JOIN ORDERTB AS B 
ON A.ID = B.CID
LEFT JOIN PRODUCTTB AS C
ON B.PID = C.PID;


DESCRIBE CUSTUMERTB;
DESCRIBE ORDERTB;
DESCRIBE PRODUCTTB;


 # IF ANS OF 'QUERRY' REQUIRE TO MAKE ONE FUNCTION I.E.----> AGGRIGATE FUNCTION AND WE HAVE 2 TABLES.
 # THEN WE HAVE TO MAKE AGGRIGATE FUNCTION 1ST,THAT FUNCTION WE HAVE TO STORE IN THE TABLE, THEN AFTER THAT WE HAVE TO USE JOIN FUNCTION  
 
DROP TABLE CUSTUMER_TB11;
CREATE TABLE CUSTUMER_TB11 
(
ID INT,
NAME VARCHAR(20),
AGE TINYINT,
ADDRESS VARCHAR(50),
WALLET_BAL FLOAT
);
SELECT * FROM CUSTUMER_TB11 ;

INSERT INTO CUSTUMER_TB11 VALUES (1, "RAMESH", 32, "ADMEDABAD", 200);
INSERT INTO CUSTUMER_TB11 VALUES (2, "KHILAN", 23, "DELHI", 7500);
INSERT INTO CUSTUMER_TB11 VALUES (3, "KAUSHIK", 25, "KOTA", 12000);
INSERT INTO CUSTUMER_TB11 VALUES (4, "CHAITALI", 22, "MUMBAI", 6500);
INSERT INTO CUSTUMER_TB11 VALUES (5, "HARDIK", 27, "BHOPAL", 6500);
INSERT INTO CUSTUMER_TB11 VALUES (6, "KOMAL", 26, "MP", 750);
INSERT INTO CUSTUMER_TB11 VALUES (7, "MUFFY", 27, "INDORE", 500);

DROP TABLE TEST30;
CREATE TABLE TEST30 AS
 (
 SELECT C_ID,SUM(AMOUNT) AS TOTAL_AMOUNT
 FROM ORDER_TB
 GROUP BY C_ID
 );
 SELECT * FROM TEST30;
 
SELECT A.NAME,B.TOTAL_AMOUNT FROM CUSTUMER_TB11 AS A 
LEFT JOIN TEST30 AS B 
ON A.ID=B.C_ID;

#    OR   ( WE CAN WRITE THE SAME QUERY IN DIFFERENT MANNER. )

SELECT A.NAME,B.TOTAL_AMOUNT FROM CUSTOMER_TB1 AS A 

LEFT JOIN 

(SELECT C_ID,SUM(AMOUNT) AS TOTAL_AMOUNT
 FROM ORDER_TB
 GROUP BY C_ID) AS B 
 
ON A.ID=B.C_ID;

##############################################################################################################################################
# ADVANCE SQL

# WHENEVER WE RUN THE TABLE , IT IS BEST PRACTICE TO WRITE 'LIMIT' CONDITION IN 'SELECT' STATEMENT
SELECT * FROM ELE_STORE1 LIMIT 10;

USE FLIPKART_DB;
# DERIVED COLUMN

DROP TABLE SALES_CAL;
CREATE TABLE SALES_CAL
(
PRODUCT_ID INT,
PRODUCT_NAME VARCHAR(20),
MRP INT,
QUANTITY INT
);

INSERT INTO SALES_CAL VALUES (1, "VIVO", 9000, 3);
INSERT INTO SALES_CAL VALUES (2, "IPHONE", 27000, 5);
INSERT INTO SALES_CAL VALUES (3, "ONEPLUS", 16000, 4);
INSERT INTO SALES_CAL VALUES (4, "SAMSUNG", 7500, 6);

SELECT * FROM SALES_CAL;

SELECT PRODUCT_ID,PRODUCT_NAME,MRP,QUANTITY,(MRP*QUANTITY) AS SALES
FROM SALES_CAL;

SELECT PRODUCT_ID,PRODUCT_NAME,MRP,QUANTITY,(MRP*QUANTITY) AS SALES
FROM SALES_CAL
HAVING SALES>50000; # WE CAN APPLY FILTER ON 'DERIVED COLUMN' BY USING 'HAVING CLAUSE'.
# AFTER EXECUTION OF THIS ABOVE QUERY, WE WILL GET 5 COLUMNS , 5TH COLUMN IS 'SALES' COLUMN WHICH WILL BE CALLED AS 'DERIVED' COLUMN.


#EX.2 
DROP TABLE SALES_CAL1;
CREATE TABLE SALES_CAL1
(
PRODUCT_ID INT,
PRODUCT_NAME VARCHAR(20),
MRP INT,
QUANTITY INT
);
INSERT INTO SALES_CAL1 VALUES (1, "VIVO", 9000, 3);
INSERT INTO SALES_CAL1 VALUES (2, "IPHONE", 27000, 5);
INSERT INTO SALES_CAL1 VALUES (3, "VIVO", 16000, 4);
INSERT INTO SALES_CAL1 VALUES (4, "SAMSUNG", 7500, 6);

SELECT * FROM SALES_CAL1;

SELECT PRODUCT_ID,PRODUCT_NAME,MRP,QUANTITY,MRP*QUANTITY AS SALES
FROM SALES_CAL1
GROUP BY PRODUCT_NAME
HAVING SALES>50000;

# HERE 2 SAME PRODUCTS ARE IN PRODUCT_NAME COLUMN STILL WE ARE NOT APPLYING 'GROUP BY' CLAUSE ON PRODUCT_NAME HERE. BEACUSE WE HAVE NOT USE ANY AGGRIGATE 
# FUNCTION. WE MADE ONE DERIVED COLUMN HERE SO WE CAN'T USE GROUP BY WITH ANY COLUMN PRESENT BEFORE THE DERIVED COLUMN.

#EX.3
DROP TABLE SALES_CAL2;
CREATE TABLE SALES_CAL2
(
PRODUCT_ID INT,
PRODUCT_NAME VARCHAR(20),
MRP INT,
QUANTITY INT
);
INSERT INTO SALES_CAL2 VALUES (1, "VIVO", 9000, 3);
INSERT INTO SALES_CAL2 VALUES (2, "IPHONE", 27000, 5);
INSERT INTO SALES_CAL2 VALUES (3, "ONEPLUS", 16000, 4);
INSERT INTO SALES_CAL2 VALUES (4, "SAMSUNG", 7500, 6);

SELECT * FROM SALES_CAL2;

SELECT PRODUCT_ID,PRODUCT_NAME,MRP,QUANTITY,MRP*QUANTITY AS SALES
FROM SALES_CAL2
GROUP BY PRODUCT_NAME
HAVING SALES>50000;

# HERE ALL PRODUCTS ARE DIFFERENT IN PRODUCT_NAME COLUMN IF WE TRY TO APPLY 'GROUP BY' CLAUSE ON PRODUCT_NAME THEN ALSO WE ARE NOT GETTING O/P 
# BEACUSE WE HAVE NOT USE ANY AGGRIGATE FUNCTION. WE MADE ONE DERIVED COLUMN HERE ALSO SO WE CAN'T USE GROUP BY WITH ANY COLUMN PRESENT BEFORE THE 
# DERIVED COLUMN.


                                 ## NOW WE WILL LEARN 'WINDOW FUNCTION' or 'ANALYTICAL FUNCTION' or 'ADVANCE FUNCTIONS'. ##
USE FLIPKART_DB;
 # EX.1
DROP TABLE IF EXISTS STUDENT_MARKS_TB;
CREATE TABLE STUDENT_MARKS_TB
(
ID INT,
NAME VARCHAR(20),
MARKS INT
);

INSERT INTO STUDENT_MARKS_TB VALUES(1, 'SANTHOSH',75);
INSERT INTO STUDENT_MARKS_TB VALUES(2, 'KIRAN',90);
INSERT INTO STUDENT_MARKS_TB VALUES(3, 'ARJUN',77);
INSERT INTO STUDENT_MARKS_TB VALUES(4, 'KARTHIK',97);
INSERT INTO STUDENT_MARKS_TB VALUES(5, 'RAJEV',65);
INSERT INTO STUDENT_MARKS_TB VALUES(6, 'GOPAL',65);
INSERT INTO STUDENT_MARKS_TB VALUES(7, 'TARUN',35);
INSERT INTO STUDENT_MARKS_TB VALUES(8, 'DIYA',99);

SELECT * FROM STUDENT_MARKS_TB;

# WHO IS THE HIGHEST MARKS HOLDER? (FIRST RANK STUDENT?)
SELECT NAME,MARKS FROM STUDENT_MARKS_TB
ORDER BY MARKS DESC
LIMIT 1;

# WHO IS THE LOWEST MARKS HOLDER? (LAST RANK STUDENT?)
SELECT NAME,MARKS FROM STUDENT_MARKS_TB
ORDER BY MARKS
LIMIT 1;

#  WHOES RANK IS 3RD?
SELECT NAME,MARKS FROM STUDENT_MARKS_TB
ORDER BY MARKS DESC
LIMIT 2,1;    # 2,1 ----> 1st 2 means skip 2 rows and 2nd 1 means No.OF ROWS WE WANT.


#  WHOES RANK IS 3RD?

# SELECT NAME,MARKS FROM STUDENT_MARKS_TB      # [ CONSIDER THIS COMPLETE QUERY AS TABLE SO WE CAN USE THIS IN FURTHER CODE. AND WE CAN DRAW 
                                               #  INFO FROM TABLE ]
# ORDER BY MARKS DESC                          # [ WE HAVE DONE THIS IN FOLLOWINF QUERY. ]
# LIMIT 1;                                     # 


SELECT * FROM                                                                     #
(                                              #                                  #
SELECT NAME,MARKS FROM STUDENT_MARKS_TB        #                                  #  
ORDER BY MARKS DESC                            #    THIS IS THE TABLE WE USED IN  #   THIS QUERY.
LIMIT 3                                        #                                  #
)                                              #                                  #
ORDER BY MARKS ASC LIMIT 1;                                                       #

USE FLIPKART_DB;
# BUT IN REAL WORLD WE ARE NOT USING THIS APPROACH.
# FOR THIS WE USE 'RANK()' FUNCTION.   [VVV IMP Q FOR INTERVIEW.]

SELECT *,RANK() OVER(ORDER BY MARKS DESC) AS RNK FROM STUDENT_MARKS_TB; # HERE WE ARE GETTING EACH AND EVERY ONE'S RANK. 
# NOW CONSIDER ABOVE QUERY AS TABLE USE IT IN THE FOLLOWING QUERY.
 
SELECT * FROM 
(
SELECT *,RANK() OVER (ORDER BY MARKS DESC) AS RNK FROM STUDENT_MARKS_TB
) AS A WHERE RNK=5;
 
 SELECT *,RANK() OVER (ORDER BY MARKS DESC) RNK FROM STUDENT_MARKS_TB HAVING RNK =5; # WE CANT GO WITH THIS LOGIC BECAUSE WE CANT APPLY HAVING CLAUSE
 # ON WINDOW FUNCTION.
 
 
 # EX.2
 DROP TABLE IF EXISTS EMPLOYEETB;
 CREATE TABLE EMPLOYEETB
 (
 EID INT ,
 DEPT VARCHAR(20),
 SALARY INT
 );
 
INSERT INTO EMPLOYEETB VALUES(1001,'ADMIN',7500);
INSERT INTO EMPLOYEETB VALUES(1002,'FINANCE',6500);
INSERT INTO EMPLOYEETB VALUES(1003,'ADMIN',7600);
INSERT INTO EMPLOYEETB VALUES(1004,'ADMIN',6500);
INSERT INTO EMPLOYEETB VALUES(1005,'FINANCE',6800);
INSERT INTO EMPLOYEETB VALUES(1006,'IT',4500);
INSERT INTO EMPLOYEETB VALUES(1007,'IT',9000);
INSERT INTO EMPLOYEETB VALUES(1008,'IT',8500);
INSERT INTO EMPLOYEETB VALUES(1009,'NON IT',9500);
INSERT INTO EMPLOYEETB VALUES(1010,'NON IT',10000);
SELECT * FROM EMPLOYEETB; 

 # WHICH EMPLOYEE HAS 3RD HIGHEST SALARY? ('HIGHEST RANK'?)
SELECT * FROM
(
SELECT *,RANK()OVER(ORDER BY SALARY DESC )RNK FROM EMPLOYEETB
)AS T WHERE RNK=3;


 # NOW IF ANY ONE ASK ABOUT THE 9TH RANK IN ABOVE DATA SET THEN, WE RUN THE SAME QURRY BUT WE ARE NOT GETTING THE ANS.
SELECT *,RANK()OVER(ORDER BY SALARY DESC )RNK FROM EMPLOYEETB;

SELECT * FROM
(
SELECT *,RANK()OVER(ORDER BY SALARY DESC )RNK FROM EMPLOYEETB
)AS T WHERE RNK=9;

 # WE ANR NOT GETTING ANY THING. WHY?, BECAUSE IN MAIN TABLE OF RANK WE FOUND THAT TWO STUDENT HAS SAME MARKS AND THAT'S WHY THEY GOT SAME RANK 
 #I.E.'8' AND '8' SO THAT'S WHY SQL SKIP THE 9TH RANK .
 
 ######   TO HANDEL THIS WE HAVE ANOTHER FUNCTION I.E. DENSE_RANK() WRITE SAME QUERY BUT WRITE DENSE_RANK() INSTED OF RANK(). ######
 
 # DENSE_RANK()
 
 SELECT *,DENSE_RANK()OVER(ORDER BY SALARY DESC)RNK FROM EMPLOYEETB;
 
 SELECT * FROM
(
SELECT *,DENSE_RANK()OVER(ORDER BY SALARY DESC)RNK FROM EMPLOYEETB
)AS T WHERE RNK=9;

# "RANK()" :- IN RANK FUNCTION RANK WILL BE SKIPPED
# "DENSE_RANK()" :- IN THIS DENSE_RANK() RANK WILL NOT BE SKIPPED RANKS WILL BE IN CONSECUTIVE ORDER.

# NOW THERE IS ONE Q. THAT, HAVE ANY ONE SEEN THAT,IN OLYMPICS 2 OR MORE THAN 2 PERSONS ARE STANDING ON ANY OF THE 1ST/2ND/3RD POSTION?
# HERE ALSO EID:- '1002' AND '1004' HAS SAME SALARY THATS WHY THEY GOT SAME RANK '8' AND '8'. BUT IT IS NOT GOOD, HOW WE CAN 
# GIVE ONE PRICE TO 2 PERSON. THEN FOR THAT WE HAVE FOLLOWING SOLUTION ON THIS.

# WE WILL USE 'ROW NUMBER'
SELECT *,ROW_NUMBER() OVER (ORDER BY MARKS DESC) RNK FROM STUDENT_MARKS_TB;
# NOW HERE WE GET THE UNIQUE RANK. IT WILL 1T ARRANGE WITH 'SALARY' THEN EITHER BY 'EID' OR 'NMAE' IN THIS EX.


# MOST IMP INTERVIEW Q.

# FETCH 3RD HIGHEST SALARIED PERSON?
# DIFFERENCE BETWEEN RANK() AND DENSE_RANK() ?
# DIFFERENCE BETWEEN RANK(),DENSE_RANK(),ROW_NUMBER ?
# FETCH 3RD HIGHEST SALARIED PERSON BY DEPARTMENT?

# 'PARTITION BY'
DROP TABLE IF EXISTS STUDENT_MARKS_TB_1;
CREATE TABLE STUDENT_MARKS_TB_1 (
ID INT,
NAME VARCHAR(20),
MEDIUM VARCHAR(20),
MARKS INT);

INSERT INTO STUDENT_MARKS_TB_1 VALUES(1, 'SANTHOSH','ENGLISH',75);
INSERT INTO STUDENT_MARKS_TB_1 VALUES(2, 'KIRAN','KANNADA',90);
INSERT INTO STUDENT_MARKS_TB_1 VALUES(3, 'ARJUN','KANNADA',77);
INSERT INTO STUDENT_MARKS_TB_1 VALUES(4, 'KARTHIK','ENGLISH',97);
INSERT INTO STUDENT_MARKS_TB_1 VALUES(5, 'RAJEV','ENGLISH',65);
INSERT INTO STUDENT_MARKS_TB_1 VALUES(6, 'GOPAL','KANNADA',65);
INSERT INTO STUDENT_MARKS_TB_1 VALUES(7, 'TARUN','ENGLISH',35);
INSERT INTO STUDENT_MARKS_TB_1 VALUES(8, 'DIYA','KANNADA',99);
SELECT * FROM STUDENT_MARKS_TB_1;
# NOW IN ABOVE IF I WANT RANK OF STUDENT IN TERMS OF MEDIUM ?
SELECT *, DENSE_RANK()
OVER(ORDER BY MEDIUM,MARKS DESC) RNK
FROM STUDENT_MARKS_TB_1
WHERE MEDIUM='ENGLISH'
UNION
SELECT *, DENSE_RANK()
OVER(ORDER BY MEDIUM,MARKS DESC) RNK
FROM STUDENT_MARKS_TB_1
WHERE MEDIUM='KANNADA';

# BUT CONSIDER THAT IF WE HAVE 10 SUB THEN SHOULD WE WRITE 10 UNION CONDITION INTO IT? 
# ANS:- NO THIS IS NOT GOOD WAY TO WRITE.

SELECT *,RANK() OVER (PARTITION BY MEDIUM ORDER BY MARKS DESC) AS RNK 
FROM STUDENT_MARKS_TB_1;

SELECT *,DENSE_RANK() OVER (PARTITION BY MEDIUM ORDER BY MARKS DESC) AS RNK 
FROM STUDENT_MARKS_TB_1;

SELECT *,ROW_NUMBER() OVER (PARTITION BY MEDIUM ORDER BY MARKS DESC) AS RNK 
FROM STUDENT_MARKS_TB_1;
# SO THIS IS THE CORRECT APPROACH.

#AVG
# WHAT IS THE AVG MARKS?
SELECT *,AVG(MARKS) OVER() FROM STUDENT_MARKS_TB_1;
# WHAT IS THE AVG MARKS BY MEDIUM?
SELECT *,AVG(MARKS) OVER(PARTITION BY MEDIUM) FROM STUDENT_MARKS_TB_1;
# WHAT IS THE CUMILATIVE AVG MARKS BY MEDIUM?
SELECT *,AVG(MARKS) OVER(PARTITION BY MEDIUM ORDER BY MARKS DESC)FROM STUDENT_MARKS_TB_1;

# MIN MAX
# WHAT IS THE MIN AND MAX OF THE MARKS?
SELECT *, MIN(MARKS)OVER(),
MAX(MARKS)OVER() FROM STUDENT_MARKS_TB_1;
# WHAT IS THE MIN AND MAX OF THE MARKS BY MEDIUM?
SELECT *, MIN(MARKS)OVER(PARTITION BY MEDIUM),
MAX(MARKS)OVER(PARTITION BY MEDIUM) FROM STUDENT_MARKS_TB_1;

# FIND ALL THE STUDENTS WHOES MARKS ARE MORE THAN THE AVG MARKS OF THERE RESPECTIE MEDIUM?
SELECT * FROM
(SELECT *,AVG(MARKS)OVER(PARTITION BY MEDIUM)AS MEDIUM_AVG 
FROM STUDENT_MARKS_TB_1) AS A 
WHERE A.MARKS>A.MEDIUM_AVG;

CREATE DATABASE ZOMATO;
USE ZOMATO;
SELECT * FROM ORDERS;

# FIND TOP 2 MOST PAYING CUSTOMERS OF EACH MONTH?
SELECT * FROM (SELECT MONTHNAME(date) AS 'month', user_id, SUM(amount) AS 'total',
               RANK() OVER(PARTITION BY MONTHNAME(date) ORDER BY SUM(amount) DESC) AS 'month_rank'
				FROM orders
				GROUP BY MONTHNAME(date), user_id
				ORDER BY MONTHNAME(date)) t
                WHERE t.month_rank < 3
                ORDER BY month DESC, month_rank ASC;
CREATE DATABASE CAMPUSX;                
USE CAMPUSX;
# FIRST_VALUE/. LAST VALUE/. NTH_VALUE

SELECT *,
FIRST_VALUE(marks) OVER(ORDER BY marks DESC)
FROM marks;

SELECT *,
LAST_VALUE(marks) OVER(ORDER BY marks DESC)
FROM marks;

# A frame in a window function is a subset of rows within the partition that determines the scope of the window function calculation. 
# The frame is defined using a combination of two clauses in the window function: ROWS and BETWEEN.
# The ROWS clause specifies how many rows should be included in the frame relative to the current row. 
# For example, ROWS 3 PRECEDING means that the frame includes the current row and the three rows that precede it in the partition.
# The BETWEEN clause specifies the boundaries of the frame. 

# Examples.

# ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW: means that the frame includes all rows from the beginning of the partition up to and including 
# the current row.

# ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING: the frame includes the current row and the row immediately before and after it.

# ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING: the frame includes all rows in the partition.

# ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING: the frame includes the current row and the three rows before it and the two rows after it.				

# WE WILL SEE HOW ABOVE "FRAMES" CONCEPT WILL WORK.., SO FOR THAT CONSIDER FOLLOWING QUERIES AND FOLLWOED BY EXPLANATION.

# CONSIDER THE FOLLOWING DATA
#     NAME         BRANCH           MARKS     
#    NITISH         EE                82 
#    RISHABH        EE                91 
#    ANUKANT        EE                69
#    RUPESH         EE                55           ENTIRE DATA
#    SHUBHAM        CS                78
#    VED            CS                43
#    DEEPAK         CS                98
#    ARPAN          CS                95

SELECT *,
FIRST_VALUE(marks) OVER(ORDER BY marks DESC)
FROM marks;

SELECT *,
LAST_VALUE(marks) OVER(ORDER BY marks DESC)
FROM marks;

 # 1) ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW:-
#     NAME         BRANCH           MARKS                                  #    NAME         BRANCH         MARKS   LAST VALUE     FIRST VALUE     
 
 #    NITISH         EE                82                          PR,CR      RISHABH        EE             91         91           91
 #    RISHABH        EE                91    SORT DATA IN DESC -->    CR      NITISH         EE             82         82           91
 #    ANUKANT        EE                69                             CR      ANUKANT        EE             69         69           91
 #    RUPESH         EE                55                             CR      RUPESH         EE             55         55           91
 
 # GROUPED DATA BY BRANCH ABOVE AND BELOW
 
 #     NAME         BRANCH           MARKS
 
 #    SHUBHAM        CS                78
 #    VED            CS                43
 #    DEEPAK         CS                98
 #    ARPAN          CS                95

 # PR--> PREVIOUS ROW, CR--> CURRENT ROW
 
 
 # ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING:-
 #     NAME         BRANCH           MARKS                                   #     NAME         BRANCH         MARKS   LAST VALUE     FIRST VALUE
 
 #    NITISH         EE                82           1) PR,CR,NR, 2)PR              RISHABH        EE             91       82              91
 #    RISHABH        EE                91    SORT DATA             CR,    PR       NITISH         EE             82       64              91
 #    ANUKANT        EE                69    IN DESC -->           NR  3) CR   PR  ANUKANT        EE             69       55              82
 #    RUPESH         EE                55                                 NR 4)NR  RUPESH         EE             55       55              69
 
  # GROUPED DATA BY BRANCH ABOVE AND BELOW
 
 #     NAME         BRANCH           MARKS
 
 #    SHUBHAM        CS                78
 #    VED            CS                43
 #    DEEPAK         CS                98
 #    ARPAN          CS                95
 
 # PR--> PREVIOUS ROW, CR--> CURRENT ROW  NR-->NEXT ROW
 
 
 # THIS FOLLOWING QUERRIES IS FOR ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
 SELECT *,
LAST_VALUE(marks) OVER(ORDER BY marks DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
FROM marks;

SELECT *,
LAST_VALUE(marks) OVER(PARTITION BY BRANCH ORDER BY marks DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING)
FROM marks;

 # ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING:- [ENTIRE DATA IS FRAME]---->VVVV IMP. FOR 1ST VALUE & LAST VALUE USE THIS FRAME OPTION.
 #     NAME         BRANCH           MARKS                                 #    NAME         BRANCH         MARKS   LAST VALUE    FIRST VALUE
 
 #    NITISH         EE                82                FR(FIRST ROW) CR       RISHABH        EE             91      55              91
 #    RISHABH        EE                91.    SORT DATA                CR       NITISH         EE             82      55              91 
 #    ANUKANT        EE                69     IN DESC -->              CR       ANUKANT        EE             69      55              91
 #    RUPESH         EE                55                LR(LAST ROW)  CR       RUPESH         EE             55      55              91
 
 # GROUPED DATA BY BRANCH ABOVE AND BELOW

 #     NAME         BRANCH           MARKS
 
 #    SHUBHAM        CS                78
 #    VED            CS                43
 #    DEEPAK         CS                98
 #    ARPAN          CS                95
# CR--> CURRENT ROW

# SAME AS ABOVE, "ROWS BETWEEN 1 PRECEDING AND 1 FOLLOWING " HERE ONLY DIFFERENCE IS "ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING"
 # ROWS BETWEEN 3 PRECEDING AND 2 FOLLOWING:-
 #     NAME         BRANCH           MARKS                                  #     NAME         BRANCH         MARKS  LAST VALUE   FIRST VALUE
 
 #    NITISH         EE                82                                         RISHABH        EE             91      
 #    RISHABH        EE                91     SORT DATA IN DESC -->               NITISH         EE             82
 #    ANUKANT        EE                69                                         ANUKANT        EE             69
 #    RUPESH         EE                55                                         RUPESH         EE             55
 
  # GROUPED DATA BY BRANCH ABOVE AND BELOW
 
 #     NAME         BRANCH           MARKS
 
 #    SHUBHAM        CS                78
 #    VED            CS                43
 #    DEEPAK         CS                98
 #    ARPAN          CS                95
 
 ## NTH_VALUE         [HERE DIRECTLY WE GET 2ND RANK STUDENT. WE CAN GET 4TH,7TH,8TH,9TH ETC...]
 SELECT *, NTH_VALUE (name, 2) OVER (PARTITION BY branch ORDER BY marks DESC 
                                     ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) 
FROM MARKS;

# FIND THE TOPEER OF EACH BRANCH WITH IT's MARKS.

SELECT name, branch, marks FROM (SELECT*,
FIRST_VALUE(name) OVER(PARTITION BY branch ORDER BY marks DESC) AS 'topper_name',
FIRST_VALUE(marks) OVER(PARTITION BY branch ORDER BY marks DESC) AS
"topper_marks"
FROM marks) t
WHERE .name = t. topper_name AND t.marks = t.topper_marks;

# FIND THE LAST PERSON OF EACH BRANCH WITH IT's MARKS.
SELECT name, branch, marks FROM ( SELECT*,
LAST_VALUE(name) OVER(PARTITION BY branch ORDER BY marks DESC
                     ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS 'topper_name',
LAST_VALUE(marks) OVER(PARTITION BY branch ORDER BY marks DESC
                      ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS "topper_marks"
FROM marks) t
WHERE .name = t. topper_name AND t.marks = t.topper_marks;

#                                        OR

SELECT name, branch, marks FROM ( SELECT*,
LAST_VALUE(name) OVER W AS 'topper_name',
LAST_VALUE(marks) OVER W AS "topper_marks"
FROM marks) t
WHERE .name = t. topper_name AND t.marks = t.topper_marks

WINDOW W AS (PARTITION BY branch ORDER BY marks DESC ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING);

## LEAD & LAG

SELECT *,
LAG (marks) OVER(ORDER BY student_id),
LEAD (marks) OVER(ORDER BY student_id)
FROM marks;

SELECT *,
LAG (marks)  OVER(PARTITION BY branch ORDER BY student_id),
LEAD (marks) OVER(PARTITION BY branch ORDER BY student_id)
FROM marks;

# FIND MOMTH ON MONTH REVENUE GROWTH OF ZOMATO?
USE ZOMATO;

SELECT MONTHNAME(date),SUM(amount),
((SUM(amount) - LAG(SUM(amount)) OVER(ORDER BY MONTH(date)))/LAG(SUM(amount))OVER(ORDER BY MONTH(date)))*100
FROM orders
GROUP BY MONTHNAME(date)
ORDER BY MONTHNAME(date) ASC;

CREATE DATABASE IPL;
USE IPL;
										    ## PL-SQL (PL-PROCEDURAL LANGUAGE) ##
                                                        
                                                        
# VV IMP Q. FOR INTERVIEW.
													
# WHAT IS THE DIFFERENCE BETWEEN SQL AND PL-SQL?                                                        
# WHAT IS  THE DIFFERENCE BETWEEN PROCEDURE AND FUNCTIONS?                                                    
                                                        
# INTRODUCTION:->															
# PL-SQL IS COMBINATION OF SQL ALONG WITH THE PROCEDURAL FEATURES OF PROGRAMMING LANGUAGES.
# PL-SQL ADDS MANY PROCEDURTAL CONSTRAINTS TO SQL LANGUAGE TO OVERCOME SOME LIMITATION OF SQL.
# SQL EXECUTES THE SINGLE LINE QUERY AT TIME WHERE AS,PL/SQL EXECUTES THE BLOCK OF CODE.


 # PROCEDURE IS STORED PROGRAM THAT YOU CAN PASS PARAMETERS INTO AND GET RESULTS AS YOU DESIRE
 # A "PROCEDURE" IS A SUBROUTINE.
 # PROCEDURE HAS A NAME,A PARAMETER LIST, AND SQL STATEMENT
 
DELIMITER $$  # [ $$ ------ $$ IT MEANS BLOCK OF CODE ]
CREATE PROCEDURE GETCALLDETAILS()
BEGIN
SELECT * FROM CAR_DATA;
END
$$

CALL GETCALLDETAILS();


# IF MANAGER WANTS YEARLY INFO THEN INSTED OF WRITING REPETED CODE WE WILL DO FOLLOWING CODE :-

DELIMITER &&
CREATE PROCEDURE GETCARCOUNTBYYEAR()
BEGIN
SELECT COUNT( * ) AS TOTAL_CARS FROM CAR_DATA WHERE YEAR=2015;
END
&&

CALL GETCARCOUNTBYYEAR();

# NOW HERE WE GET INFO OF YEAR 2015 BECAUSE WE MENTION 2105 IN CODE BUT MANAGER ASKED ABOUT MULTPULE YEARS THEN ?
DELIMITER &&
CREATE PROCEDURE GETCARCOUNTBYYEAR1(IN YEARR INT)
BEGIN
SELECT COUNT( * ) AS TOTAL_CARS FROM CAR_DATA WHERE YEAR=YEARR;
END
&&

CALL GETCARCOUNTBYYEAR1(2017);


# COMPLEX QUERY

# CAN YOU TELL ME HOW MUCH SALES HAPPENED IN 2020? //2018/2019?

# 1ST CREATE TABLE
DROP TABLE SALES;
CREATE TABLE SALES
(
ID INT,
SALES INT,
DATE DATE
);

INSERT INTO SALES VALUES(1,2000,'2019-12-10');
INSERT INTO SALES VALUES(1,4000,'2019-01-13');
INSERT INTO SALES VALUES(1,3500,'2020-02-06');
INSERT INTO SALES VALUES(2,1500,'2019-12-10');
INSERT INTO SALES VALUES(2,750,'2020-11-12');
INSERT INTO SALES VALUES(3,35,'2020-04-05');
INSERT INTO SALES VALUES(3,1750,'2019-11-10');
INSERT INTO SALES VALUES(2,1353,'2018-05-07');
INSERT INTO SALES VALUES(4,5000,'2018-11-19');
INSERT INTO SALES VALUES(4,1250,'2020-06-07');
INSERT INTO SALES VALUES(2,5200,'2020-12-31');
INSERT INTO SALES VALUES(4,4500,'2019-12-31');
INSERT INTO SALES VALUES(5,3000,'2020-10-31');
INSERT INTO SALES VALUES(2,7500,'2018-12-31');

SELECT * FROM SALES; 

SELECT EXTRACT(YEAR FROM DATE)AS YR, SUM(SALES) FROM SALES 
GROUP BY YR;
# THIS WILL GIVE FOLLOWING O/P.
# YR     SUM(SALES)
# 2019   13750
# 2020   13735
# 2018   13853


# AS WE WANT ONLY ONE YEAR THEN
SELECT SUM(SALES) FROM SALES WHERE EXTRACT(YEAR FROM DATE)=2018;
#                           OR
SELECT SUM(SALES) FROM SALES WHERE EXTRACT(YEAR FROM DATE)=2019;
# NOW IN ABOVE Q. MAY RAISE THAT HOW WE USED 'WHERE CLAUSE' WITH 'DERIVED COLUMN' I.E. "YEAR" WITH HELP OF 'EXTRACT' HERE ?

# ANS:- HERE "YEAR" IS 'DERIVED COLUMN' BUT IT IS NOT 'AGGRIGATED COLUMN' SO WE CAN USE IT.
# NOW ANOTHER REASON IS THAT THAT COLUMN IS OF 'DATE' DATA TYPE. SO WE CAN USE WHERE CLAUSE WITH 'DATE' DATA TYPE COLUMN.


# CAN YOU TELL ME HOW MUCH SALES HAPPENED IN 2020? //2018/2019?


DROP PROCEDURE IF EXISTS GETSALESBYYEAR;
DELIMITER &&
CREATE PROCEDURE GETSALESBYYEAR(IN YR INT)
BEGIN
SELECT SUM(SALES) FROM SALES WHERE EXTRACT(YEAR FROM DATE)=YR;
END
&&

CALL GETSALESBYYEAR(2019);

# IF CLIENT ASKING BETWEEN 2 DATES THEN...

SELECT SUM(SALES) FROM SALES 
WHERE DATE BETWEEN '2019-01-01' AND '2019-06-30';

# WITH THE HELP OF DELIMITER;

DROP PROCEDURE IF EXISTS GETSALESBYYEAR1;
DELIMITER &&
CREATE PROCEDURE GETSALESBYYEAR1(IN START_DATE DATE,
IN END_DATE DATE)
BEGIN
SELECT SUM(SALES) FROM SALES WHERE DATE BETWEEN START_DATE AND END_DATE;
END
&&

CALL GETSALESBYYEAR1('2019-01-01','2019-06-30');


# EX.1
# TELL ME THE STATUS OF EACH ID WEATHER THEY BELONGS TO THE EITHER PLATINUM,GOLD OR SILVER ?

# SUM OF SALES FOR ALL ID. 
SELECT * FROM sales;
SELECT id, SUM(sales) FROM sales
GROUP BY id;

# SUM OF SALES FOR ID=3
SELECT SUM(SALES) FROM SALES 
 WHERE ID = 3;

# EXACT CODE:-
DROP PROCEDURE IF EXISTS CUSTUMER_STATUS;

DELIMITER $$
CREATE  PROCEDURE CUSTUMER_STATUS
(
 IN V_ID INT,
 OUT V_STATUS VARCHAR(20)
 )
BEGIN
DECLARE PURCHASE INT DEFAULT 0;
SELECT SUM(SALES) INTO PURCHASE FROM SALES 
 WHERE ID = V_ID
 GROUP BY ID;
 IF PURCHASE > 10000 THEN
        SET V_STATUS = 'PLATINUM';
ELSEIF PURCHASE <= 5000 THEN
        SET V_STATUS = 'SILVER';
ELSE
        SET V_STATUS = 'GOLD';
END IF;
 END;
$$

CALL CUSTUMER_STATUS(1,@V_STATUS)        # OR # CALL CUSTUMER_STATUS(2,@V_STATUS)   # OR # CALL CUSTUMER_STATUS(3,@V_STATUS)
                                         # OR # CALL CUSTUMER_STATUS(4,@V_STATUS)   # OR # CALL CUSTUMER_STATUS(5,@V_STATUS)
SELECT @V_STATUS;


# EX.2 
# BASED ON CUSTOMER ID HOW MANY DAYS IT WILL TAKE OFR SHEEPING PURPOSE ?

DROP TABLE IF EXISTS CUSTOMER_INFO_3;
CREATE TABLE CUSTOMER_INFO_3
(
ID INT,
CONSTRAINT PK_ID PRIMARY KEY(ID),

FIRST_NAME VARCHAR(20) NOT NULL,
LAST_NAME VARCHAR(20),

AGE TINYINT,

ADDRESS VARCHAR(100) UNIQUE,
DEPARTMENT VARCHAR(10) ,

PHONE_NUMBER BIGINT
);

INSERT INTO CUSTOMER_INFO_3 VALUES (1,"ANIKET","J",25,"BANGALORE","DEPT1 ",8180868800); 
INSERT INTO CUSTOMER_INFO_3 VALUES (2,"SARANSH","R",35,"CHENNAI","DEPT2 ",9766917303);
INSERT INTO CUSTOMER_INFO_3 VALUES (3,"SATISH","R",63,"HYDERABAD","DEPT1 ",9423419307);
INSERT INTO CUSTOMER_INFO_3 VALUES (4,"VIDYA","L",59,"DELHI"," DEPT2",9423935317);
INSERT INTO CUSTOMER_INFO_3 VALUES (5,"KAPIL","K",25,"MUMBAI"," DEPT1",9423935318);


SELECT * FROM customer_info_3;
SELECT ADDRESS FROM customer_info_3 WHERE ID = 2;


DROP PROCEDURE IF EXISTS GetCustomerShipping;

# BASED ON CUSTOMER ID HOW MANY DAYS IT WILL TAKE OFR SHEEPING PURPOSE ?
DELIMITER $$
CREATE PROCEDURE GetCustomerShipping
(
	IN P_ID  INT, 
	OUT pShipping  VARCHAR(50)
)
BEGIN
    DECLARE V_ADDRESS VARCHAR(100);
SELECT ADDRESS INTO V_ADDRESS FROM customer_info_3
WHERE
    ID = P_ID;
   CASE V_ADDRESS     # [ # USE OF CASE:-> INSTED OF USING 'IF' MANY TIMES USE.--->  "CASE" --- "WHEN" --- "SET" ]
		WHEN  'BANGALORE' THEN
		   SET pShipping = '1-day Shipping';
		WHEN 'CHENNAI' THEN
		   SET pShipping = '2-day Shipping';
		WHEN 'MUMBAI' THEN
		   SET pShipping = '3-day Shipping';
		WHEN 'HYDERABAD' THEN
		   SET pShipping = '4-day Shipping';
		ELSE
		   SET pShipping = '5-day Shipping';
	END CASE;
END;
$$

CALL GetCustomerShipping(2,@pShipping);
SELECT @pShipping;


## FUNCTIONS IN PL-SQL

#EX.1

DROP FUNCTION calcProfit;

DELIMITER $$  
CREATE FUNCTION calcProfit
(CP FLOAT, 
SP FLOAT) 
RETURNS int
DETERMINISTIC   # WHEN RETURN WILL GIVE THE O/P (I.E. 'PROFIT') AFTER RUNNING THIS LINE OF CODE'SET profit = CP-SP;' THAT VALUE WILL GO INTO 
                # THE 'RETURN' LINE OF CODE WHICH IS PRESENT ABOVE THE 'DETERMINISTIC' WORD.
                # THIS "DETERMINISTIC" WORD IS USED FOR THE ABOVE PROCESSES. IT WILL USE ONLY IN "MYSQL". NOT IN OTHER SQL DATABASE.
BEGIN
  DECLARE profit int;
  SET profit = CP-SP;
  RETURN profit;  
END
$$

SELECT calcProfit(100,50);
SELECT calcProfit(50,100);

# EX.2

DROP FUNCTION IF EXISTS SUM_FUNCTION;
DELIMITER $$  
CREATE FUNCTION SUM_FUNCTION(
A INT, 
B INT
) 
RETURNS INT
DETERMINISTIC
Begin
  return a + b;
End
$$

SELECT SUM_FUNCTION(12,3);
SELECT 12+3;

#EX.3

drop function F_Customer_Occupation;

DELIMITER $$  
CREATE FUNCTION F_Customer_Occupation
(  
    age int  
)   
RETURNS VARCHAR(20)    
DETERMINISTIC
BEGIN  
    DECLARE customer_occupation VARCHAR(20);  
    IF age > 35 THEN  
        SET customer_occupation = 'Scientist';  
    ELSEIF (age <= 35 AND  age >= 30) THEN  
        SET customer_occupation = 'Engineer';  
    ELSEIF age < 30 THEN  
        SET customer_occupation = 'Actor';  
    END IF;  
    -- return the customer occupation  
    RETURN (customer_occupation);  -- important
END $$

SELECT F_Customer_Occupation(32);


DROP TABLE IF EXISTS test_cust;
create table test_cust (
id int,
name varchar(20),
age int
);

insert into test_cust VALUES(1,'SANTHOSH',28);
insert into test_cust VALUES (2,'KIRAN',30);
insert into test_cust VALUES (3,'KARTHIK',45);
insert into test_cust VALUES(4,'ARJUN',25);

SELECT * FROM TEST_CUST;

SELECT *, F_Customer_Occupation(AGE) FROM TEST_CUST;
# HERE WE GAVE 'COMPLETE FUNCTION' TO THE 'SELECT STATEMENT ' AS AN PARAMETR.

# DIFFERENCE BETWEEN PROCEDURE AND FUNCTION?

# PROCEDURES ARE USE FOR REPETATIVE TASK.
# PROCEDURES CAN HAVE I/P,O/P PARAMETER OR IT IS COMPLETE OPTIONAL. 
# PROCEDURES NEED NOT HAVE A WRITTEN VALUE ALL THE TIME.
# PROCEDURES CAN NOT BE USE IN SELECT CODE.
# PROCEDURES CAN GIVE TABLE IN O/P.

#                 Vs

# FUNCTIONS ARE USE FOR ANY LOGICAL OR MATHEMATICAL OPERATIONS
# FUNCTIONS WILL ALLWASY EXCEPT I/P.
# FUNCTIONS HAS TO HAVE A RETURN VALUE.
# FUNCTIONS CAN BE USE IN SELECT CODE IN ORDER TO COME UP WITH THE BETTER LOGIC.
# FUNCTIONS CAN'T GIVE BACK ME TABLE IN O/P.


# VIEWS :--> 
# IT DISPLAYS THE DATA STORED IN THE TABLE.
# IT JUST STORING QUERY NOT THE DATA.

DROP TABLE IF EXISTS CUST;
CREATE TABLE CUST (
ID INT,
NAME VARCHAR(20),
ADDRESS VARCHAR(100)
);

INSERT INTO CUST VALUES(1,"SANTHOSH","BANGALORE");
INSERT INTO CUST VALUES(2,"KIRAN","CHENNAI");
INSERT INTO CUST VALUES(3,"MAHDI","MUMBAI");
INSERT INTO CUST VALUES(4,"TAREN","BANGALORE");
INSERT INTO CUST VALUES(5,"DINESH","CHENNAI");
INSERT INTO CUST VALUES(6,"VARUN","BANGALORE");

# 1ST INSERTION
INSERT INTO CUST VALUES(99,"NEW PERSON","CHENNAI");

# 2ND INSERTION
INSERT INTO CUST VALUES(100,"NEW PERSON1","BANGALORE");
SELECT * FROM CUST;

DROP TABLE IF EXISTS P_SALES;
CREATE TABLE P_SALES (
ID INT,
PRODUCT VARCHAR(20),
SALES INT
);
INSERT INTO P_SALES VALUES(1,"VIVO",9500);
INSERT INTO P_SALES VALUES(2,"IPHONE",25000);
INSERT INTO P_SALES VALUES(4,"REDMI",7500);
INSERT INTO P_SALES VALUES(6,"SAMSUNG",8500);
INSERT INTO P_SALES VALUES(5,"SAMSUNG",9500);

# 1ST INSERTION
INSERT INTO P_SALES VALUES(99,"SAMSUNG",8000);

# 2ND INSERTION
INSERT INTO P_SALES VALUES(100,"VIVO",7500);

SELECT * FROM P_SALES;

SELECT A.NAME,A.ADDRESS,B.PRODUCT,B.SALES FROM CUST AS A
LEFT JOIN
P_SALES AS B
ON A.ID=B.ID
WHERE ADDRESS='BANGALORE';

# NOW WE CREATE VIEW


CREATE VIEW CUST_BANG AS
(
SELECT A.NAME,A.ADDRESS,B.PRODUCT,B.SALES FROM CUST AS A
LEFT JOIN
P_SALES AS B
ON A.ID=B.ID
WHERE ADDRESS='BANGALORE'
);
SELECT * FROM CUST_BANG;
#                 |
#                 |
#                 V

# HERE IN CUST_BANG WE ARE NOT STORING DATA, WE ARE STORING QUERY HERE. AFTER EXECUTION OF THAT QUERY WE WILL GET THE DATA FROM THE TABLE
# WHICH WE MENTIOND IN QUERY.

# INSERTION:-->

# 1ST INSERTION:-->
# 1ST INSERTION IN 'CUST' TABLE AS WELL AS 'P_SALES'.
# CONSIDER THAT NEW PERSON INSERTED INTO THE 'CUST' TABLE AND HE PURCHASED ONE PHONE.
#                                          |
#                                          |
#                                          V

# HERE WHATEVER WE INSERTED INTO THE TABLE WE WILL NOT GET WHEN WE EXEXUTE ---> ' SELECT * FROM CUST_BANG; ' BECAUSE LOCATION IS NOT AN
# BANGALORE HERE.


# 2ND INSERTION :-->
# 2ND INSERTION IN 'CUST' TABLE AS WELL AS 'P_SALES'.
# CONSIDER THAT, AGAIN NEW PERSON INSERTED INTO THE 'CUST' TABLE. AND HE PURCHASED ONE PHONE.
#                                          |
#                                          |
#                                          V

# HERE WHATEVER WE INSERTED INTO THE TABLE WE WILL GET WHEN WE EXEXUTE ---> ' SELECT * FROM CUST_BANG; ' BECAUSE LOCATION IS BANGALORE.

## "TRIGGER" ##

DROP TABLE IF EXISTS EMPLOYEE;
CREATE TABLE EMPLOYEE (
EMP_ID INT,
EMP_FIRST_NAME VARCHAR(20),
EMP_LAST_NAME VARCHAR(20),
AGE INT,
PHONE_NUMBER BIGINT,
ADDRESS VARCHAR(100)
);

INSERT INTO EMPLOYEE VALUES(101,"SANTHOSH","J",28,7892213354,"BANGALORE");
INSERT INTO EMPLOYEE VALUES(102,"DINESH","R",30,7418529630,"CHENNAI");
INSERT INTO EMPLOYEE VALUES(103,"DIVYA","J",29,9638527410,"BANGALORE");
INSERT INTO EMPLOYEE VALUES(104,"SANDHIYA","P",26,9874512360,"DELHI");
INSERT INTO EMPLOYEE VALUES(105,"SANJAY","S",20,9512358744,"PUNE");


SELECT * FROM EMPLOYEE;
UPDATE EMPLOYEE SET EMP_FIRST_NAME ="SANTHOSH POWER BI" WHERE EMP_ID  = 101;
UPDATE EMPLOYEE SET AGE =99 WHERE EMP_ID=101;
SELECT * FROM EMPLOYEE_HISTORY;

DROP TABLE IF EXISTS EMPLOYEE_HISTORY;
CREATE TABLE EMPLOYEE_HISTORY (
ID INT AUTO_INCREMENT PRIMARY KEY,
EMP_ID INT,
ACTION VARCHAR(20),
FIELD VARCHAR(20),
OLD_VALUE VARCHAR(20),
NEW_VALUE VARCHAR(20),
UPDATEUSER VARCHAR(20),
UPDATETIMESTAMP TIMESTAMP
);

   
DROP TRIGGER EMPLOYEE_TRIGGER;
DELIMITER $$
CREATE TRIGGER EMPLOYEE_TRIGGER
AFTER UPDATE
ON EMPLOYEE FOR EACH ROW
BEGIN
    IF OLD.EMP_FIRST_NAME <> NEW.EMP_FIRST_NAME THEN
        INSERT INTO EMPLOYEE_HISTORY(EMP_ID, ACTION,FIELD,OLD_VALUE,NEW_VALUE,UPDATEUSER ,UPDATETIMESTAMP)
        VALUES(OLD.EMP_ID,"UPDATE", "EMP_FIRST_NAME", OLD.EMP_FIRST_NAME, NEW.EMP_FIRST_NAME, USER(), CURRENT_TIMESTAMP());
    END IF;
     IF OLD.AGE <> NEW.AGE THEN
        INSERT INTO EMPLOYEE_HISTORY(EMP_ID, ACTION,FIELD,OLD_VALUE,NEW_VALUE,UPDATEUSER ,UPDATETIMESTAMP)
        VALUES(OLD.EMP_ID,"UPDATE", "AGE", OLD.AGE, NEW.AGE, USER(), CURRENT_TIMESTAMP());
    END IF;
    IF OLD.EMP_LAST_NAME <> NEW.EMP_LAST_NAME THEN
        INSERT INTO EMPLOYEE_HISTORY(EMP_ID, ACTION,FIELD,OLD_VALUE,NEW_VALUE,UPDATEUSER ,UPDATETIMESTAMP)
        VALUES(OLD.EMP_ID,"UPDATE", "EMP_LAST_NAME", OLD.EMP_LAST_NAME, NEW.EMP_LAST_NAME, USER(), CURRENT_TIMESTAMP());
    END IF;
    IF OLD.PHONE_NUMBER <> NEW.PHONE_NUMBER THEN
        INSERT INTO EMPLOYEE_HISTORY(EMP_ID, ACTION,FIELD,OLD_VALUE,NEW_VALUE,UPDATEUSER ,UPDATETIMESTAMP)
        VALUES(OLD.EMP_ID,"UPDATE", "PHONE_NUMBER", OLD.PHONE_NUMBER, NEW.PHONE_NUMBER, USER(), CURRENT_TIMESTAMP());
    END IF;
    IF OLD.ADDRESS <> NEW.ADDRESS THEN
        INSERT INTO EMPLOYEE_HISTORY(EMP_ID, ACTION,FIELD,OLD_VALUE,NEW_VALUE,UPDATEUSER ,UPDATETIMESTAMP)
        VALUES(OLD.EMP_ID,"UPDATE", "ADDRESS", OLD.ADDRESS, NEW.ADDRESS, USER(), CURRENT_TIMESTAMP());
    END IF;
END$$


SELECT * FROM EMPLOYEE;
UPDATE EMPLOYEE SET AGE =27,EMP_FIRST_NAME="SANTHOSH", ADDRESS="BANGALORE"  WHERE EMP_ID = 101;
SELECT * FROM EMPLOYEE_HISTORY;


# {
# SOME EXTRAW THINGS WITH SELECT COMMAND FROM DML
USE FLIPKART_DB;
SELECT * FROM smartphones;

# CREATING COLUMNS WITH SAME THING IN ALL ROWS.
SELECT model, 'smartphone' AS type FROM smartphones;

# DISTINCT ON TWO COLUMNS [FINDING UNIQUE ROWS BY USING 2 COLUMNS]
SELECT DISTINCT brand_name,processor_brand FROM smartphones;

# BRAND_NAME WITH PRICE> 50000
SELECT DISTINCT brand_name from smartphones where price>50000;

# FIND THE NAME OF PHONES WHERE processor_brand ='snapdragon','exynos','bionic'
SELECT DISTINCT * from smartphones where processor_brand IN ('snapdragon','exynos','bionic');


# CREATING EXPRESSION WITH COLUMNS
SELECT model,SQRT(resolution_width * resolution_width + resolution_height * resolution_height)/screen_size AS PPI FROM smartphones;
# ROUND
SELECT model,ROUND(SQRT(resolution_width * resolution_width + resolution_height * resolution_height)/screen_size) AS PPI FROM smartphones;

# STD
SELECT STD(screen_size) FROM smartphones;

# CEIL & FLOOR
SELECT CEIL(screen_size) FROM smartphones;  # 6.7 --->7
SELECT FLOOR(screen_size) FROM smartphones; # 6.7 --->6

# }


Questions

1)What is ShipperName with ShipperID -1 (Shippers Table)

Ans of 1st Question :-
SELECT ShipperName FROM Shippers where ShipperID=1;

2)What is LastName of Employee with EmployeeID-2 (Employee Table)

Ans of 2nd Question :-
SELECT LastName FROM Employees where EmployeeID=2;

3) What is Description of CategoryName=Dairy Products (Categories table)

Ans of 3rd Question :-
SELECT Description FROM Categories where CategoryName="Dairy Products";

4)What is EmployeeID of Robert king(Employees Table)

Ans of 4th Question :-
SELECT EmployeeID FROM Employees where FirstName="Robert" AND LastName="king";


Questions

1)Select all records where the City column has the value "Berlin".

Ans of 1st Question :-
SELECT * FROM Customers where City= "Berlin" ;

2)Use the NOT keyword to select all records where City is NOT "Berlin".

Ans of 2nd Question :-
SELECT * FROM Customers where city NOT "Berlin";

3)Select all records where the CustomerID column has the value 32.

Ans of 3rd Question :-
SELECT * FROM Customers where CustomerID= 30;

4)Select all records where the City column has the value 'Berlin' and the PostalCode column has the value 12209.

Ans of 4th Question :-
SELECT * FROM Customers where City="Berlin" AND PostalCode="12209";

5) Select all records where the City column has the value 'Berlin' or 'London'.

Ans of 5th Question :-
SELECT * FROM Customers where City="Berlin" OR City="London";

